// Generated by Haxe 4.1.2
(function ($hx_exports, $global) { "use strict";
$hx_exports["bunga"] = $hx_exports["bunga"] || {};
$hx_exports["sdd"] = $hx_exports["sdd"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedRight() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		let sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
}
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = "HxOverrides";
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) {
			let i1 = i.next();
			a.push(i1);
		}
		return a;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				return true;
			}
		}
		return false;
	}
	static find(it,f) {
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
}
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static getProperty(o,field) {
		let tmp;
		if(o == null) {
			return null;
		} else {
			let tmp1;
			if(o.__properties__) {
				tmp = o.__properties__["get_" + field];
				tmp1 = tmp;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return o[tmp]();
			} else {
				return o[field];
			}
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static compareMethods(f1,f2) {
		if(f1 == f2) {
			return true;
		}
		if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
			return false;
		}
		if(f1.scope == f2.scope && f1.method == f2.method) {
			return f1.method != null;
		} else {
			return false;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
}
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = "StringTools";
class XmlType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Element";
		case 1:
			return "PCData";
		case 2:
			return "CData";
		case 3:
			return "Comment";
		case 4:
			return "DocType";
		case 5:
			return "ProcessingInstruction";
		case 6:
			return "Document";
		}
	}
}
class Xml {
	constructor(nodeType) {
		this.nodeType = nodeType;
		this.children = [];
		this.attributeMap = new haxe_ds_StringMap();
	}
	get(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	set(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	exists(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	attributes() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return haxe_ds_StringMap.keysIterator(this.attributeMap.h);
	}
	elements() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		let ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	elementsNamed(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			let tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		let ret = _g;
		return new haxe_iterators_ArrayIterator(ret);
	}
	firstElement() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	addChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	removeChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	toString() {
		return haxe_xml_Printer.print(this);
	}
	static parse(str) {
		return haxe_xml_Parser.parse(str);
	}
	static createElement(name) {
		let xml = new Xml(Xml.Element);
		if(xml.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeName = name;
		return xml;
	}
	static createPCData(data) {
		let xml = new Xml(Xml.PCData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createCData(data) {
		let xml = new Xml(Xml.CData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createComment(data) {
		let xml = new Xml(Xml.Comment);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocType(data) {
		let xml = new Xml(Xml.DocType);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createProcessingInstruction(data) {
		let xml = new Xml(Xml.ProcessingInstruction);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocument() {
		return new Xml(Xml.Document);
	}
}
Xml.__name__ = "Xml";
Object.assign(Xml.prototype, {
	__class__: Xml
});
class bunga_Book {
	constructor(id,label) {
		this.id = id;
		this.label = label;
	}
}
$hx_exports["bunga"]["Book"] = bunga_Book;
bunga_Book.__name__ = "bunga.Book";
Object.assign(bunga_Book.prototype, {
	__class__: bunga_Book
});
class bunga_BookInfo {
	constructor(fasc,page,detail) {
		this.fasc = fasc;
		this.page = page;
		this.detail = detail;
	}
}
bunga_BookInfo.__name__ = "bunga.BookInfo";
Object.assign(bunga_BookInfo.prototype, {
	__class__: bunga_BookInfo
});
class bunga_SddCharacterData {
	constructor(character,states,mediaObjects) {
		this.character = character;
		this.states = states;
		this.mediaObjects = mediaObjects;
	}
}
bunga_SddCharacterData.__name__ = "bunga.SddCharacterData";
Object.assign(bunga_SddCharacterData.prototype, {
	__class__: bunga_SddCharacterData
});
class bunga_DetailData {
	constructor(name,author,nameCN,fasc,page,detail,photos,fields,name2,vernacularName,vernacularName2,meaning,noHerbier,website,herbariumPicture,extra) {
		if(bunga_DetailData._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(name,author,nameCN,fasc,page,detail,photos,fields,name2,vernacularName,vernacularName2,meaning,noHerbier,website,herbariumPicture,extra);
	}
	_hx_constructor(name,author,nameCN,fasc,page,detail,photos,fields,name2,vernacularName,vernacularName2,meaning,noHerbier,website,herbariumPicture,extra) {
		this.name = name != null ? StringTools.trim(name) : "";
		this.author = author != null ? StringTools.trim(author) : "";
		this.nameCN = nameCN != null ? StringTools.trim(nameCN) : "";
		this.name2 = name2;
		this.vernacularName = vernacularName;
		this.vernacularName2 = vernacularName2;
		this.meaning = meaning;
		this.herbariumPicture = herbariumPicture;
		this.website = website;
		this.fasc = fasc;
		this.page = page;
		this.detail = detail != null ? detail : "";
		this.photos = photos != null ? photos : [];
		this.extra = extra;
	}
	toRepresentation(extraFields) {
		let _gthis = this;
		let _g = this.name + (this.author != null ? " / " + this.author : "" + (this.nameCN != null ? " / " + this.nameCN : ""));
		let result = new Array(extraFields.length);
		let _g1 = 0;
		let _g2 = extraFields.length;
		while(_g1 < _g2) {
			let i = _g1++;
			let field = extraFields[i];
			let value = Reflect.field(field.std ? _gthis : _gthis.extra,field.id);
			result[i] = value == null || value == "" ? "" : "" + field.label + ": " + value + "<br><br>";
		}
		return new sdd_Representation(_g,"" + result.join("") + (this.fasc != null ? "Flore Madagascar et Comores<br>fasc " + this.fasc + "<br>page " + this.page + "<br><br>" : "" + this.detail),null);
	}
	static findInDescription(description,section) {
		let re = new EReg("" + bunga_ERegTools.escape(section) + "\\s*:\\s*(.*?)(?=<br><br>)","i");
		if(re.match(description)) {
			return StringTools.trim(re.matched(1));
		} else {
			return "";
		}
	}
	static removeFromDescription(description,sections) {
		let desc = description;
		let _g = 0;
		while(_g < sections.length) {
			let section = sections[_g];
			++_g;
			let re_r = new RegExp("" + bunga_ERegTools.escape(section) + "\\s*:\\s*(.*?)(?=<br><br>)","i".split("u").join(""));
			desc = desc.replace(re_r,"");
		}
		return desc;
	}
	static fromRepresentation(representation,extraFields,photosByRef) {
		let names = representation.label.split("/");
		let name = names[0];
		let author = names[1];
		let nameCN = names[2];
		let fields = bunga_Field.standard.concat(extraFields);
		let floreRe = new EReg("Flore Madagascar et Comores\\s*<br>\\s*fasc\\s+(\\d*)\\s*<br>\\s*page\\s+(null|\\d*)","i");
		let fasc = null;
		let page = null;
		if(floreRe.match(representation.detail)) {
			fasc = Std.parseInt(floreRe.matched(1));
			page = Std.parseInt(floreRe.matched(2));
		}
		let representation1 = representation.detail;
		let result = new Array(fields.length);
		let _g = 0;
		let _g1 = fields.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = fields[i].label;
		}
		let detail = bunga_DetailData.removeFromDescription(representation1,result).replace(floreRe.r,"");
		let emptyParagraphRe = new EReg("<p>(\n|\t|\\s|<br>|&nbsp;)*</p>","gi");
		if(emptyParagraphRe.match(detail)) {
			detail = detail.replace(emptyParagraphRe.r,"");
		}
		let _this = representation.mediaObjectsRefs;
		let result1 = new Array(_this.length);
		let _g2 = 0;
		let _g3 = _this.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = photosByRef[_this[i].ref];
		}
		let photos = result1;
		let data = new bunga_DetailData(name,author,nameCN,fasc,page,detail,photos,extraFields,null,null,null,null,null,null,null,null);
		let _g4 = 0;
		while(_g4 < fields.length) {
			let field = fields[_g4];
			++_g4;
			(field.std ? data : data.extra)[field.id] = bunga_DetailData.findInDescription(representation.detail,field.label);
		}
		return data;
	}
}
$hx_exports["bunga"]["DetailData"] = bunga_DetailData;
bunga_DetailData.__name__ = "bunga.DetailData";
Object.assign(bunga_DetailData.prototype, {
	__class__: bunga_DetailData
});
class bunga_Item extends bunga_DetailData {
	_hx_constructor(id,data) {
		super._hx_constructor(data.name,data.author,data.nameCN,data.fasc,data.page,data.detail,data.photos,null,data.name2,data.vernacularName,data.vernacularName2,data.meaning,data.noHerbier,data.website,data.herbariumPicture,data.extra);
		this.id = id;
	}
}
$hx_exports["bunga"]["Item"] = bunga_Item;
bunga_Item.__name__ = "bunga.Item";
Object.assign(bunga_Item.prototype, {
	__class__: bunga_Item
});
class bunga_HierarchicalItem extends bunga_Item {
	constructor(type,id,hid,parentId,topLevel,childrenIds,data) {
		if(bunga_DetailData._hx_skip_constructor) {
			super();
			return;
		}
		bunga_DetailData._hx_skip_constructor = true;
		super();
		bunga_DetailData._hx_skip_constructor = false;
		this._hx_constructor(type,id,hid,parentId,topLevel,childrenIds,data);
	}
	_hx_constructor(type,id,hid,parentId,topLevel,childrenIds,data) {
		super._hx_constructor(id,data);
		this.type = type;
		this.hid = hid;
		this.parentId = parentId;
		this.topLevel = topLevel;
		this.children = { };
		let _g = 0;
		while(_g < childrenIds.length) {
			let id = childrenIds[_g];
			++_g;
			this.children[id] = null;
		}
	}
	hydrateChildren(hierarchyById) {
		let _g = 0;
		let _g1 = Reflect.fields(this.children);
		while(_g < _g1.length) {
			let id = _g1[_g];
			++_g;
			let child = hierarchyById[id];
			if(child == null) {
				Reflect.deleteField(this.children,id);
				console.log("src/bunga/HierarchicalItem.hx:25:","Child not found: " + this.name + " > " + id);
			} else {
				this.children[id] = hierarchyById[id];
			}
		}
	}
}
bunga_HierarchicalItem.__name__ = "bunga.HierarchicalItem";
Object.assign(bunga_HierarchicalItem.prototype, {
	__class__: bunga_HierarchicalItem
});
class bunga_Character extends bunga_HierarchicalItem {
	constructor(item,states,inapplicableStates) {
		super("character",item.id,item.hid,item.parentId,item.topLevel,Reflect.fields(item.children),item);
		this.states = states;
		this.inapplicableStates = inapplicableStates;
	}
	static fromSdd(character,photosByRef,statesById) {
		let _g = character.id;
		let _g1 = character.id;
		let _g2 = character.parentId;
		let _g3 = character.parentId == null;
		let _g4 = character.childrenIds;
		let extraFields = [];
		let photosByRef1 = photosByRef;
		let names = character.label.split("/");
		let name = names[0];
		let author = names[1];
		let nameCN = names[2];
		let fields = bunga_Field.standard.concat(extraFields);
		let floreRe = new EReg("Flore Madagascar et Comores\\s*<br>\\s*fasc\\s+(\\d*)\\s*<br>\\s*page\\s+(null|\\d*)","i");
		let fasc = null;
		let page = null;
		if(floreRe.match(character.detail)) {
			fasc = Std.parseInt(floreRe.matched(1));
			page = Std.parseInt(floreRe.matched(2));
		}
		let character1 = character.detail;
		let result = new Array(fields.length);
		let _g5 = 0;
		let _g6 = fields.length;
		while(_g5 < _g6) {
			let i = _g5++;
			result[i] = fields[i].label;
		}
		let detail = bunga_DetailData.removeFromDescription(character1,result).replace(floreRe.r,"");
		let emptyParagraphRe = new EReg("<p>(\n|\t|\\s|<br>|&nbsp;)*</p>","gi");
		if(emptyParagraphRe.match(detail)) {
			detail = detail.replace(emptyParagraphRe.r,"");
		}
		let _this = character.mediaObjectsRefs;
		let result1 = new Array(_this.length);
		let _g7 = 0;
		let _g8 = _this.length;
		while(_g7 < _g8) {
			let i = _g7++;
			result1[i] = photosByRef1[_this[i].ref];
		}
		let photos = result1;
		let data = new bunga_DetailData(name,author,nameCN,fasc,page,detail,photos,extraFields,null,null,null,null,null,null,null,null);
		let _g9 = 0;
		while(_g9 < fields.length) {
			let field = fields[_g9];
			++_g9;
			(field.std ? data : data.extra)[field.id] = bunga_DetailData.findInDescription(character.detail,field.label);
		}
		let _g10 = new bunga_HierarchicalItem("character",_g,_g1,_g2,_g3,_g4,data);
		let _this1 = character.states;
		let result2 = new Array(_this1.length);
		let _g11 = 0;
		let _g12 = _this1.length;
		while(_g11 < _g12) {
			let i = _g11++;
			result2[i] = statesById[_this1[i].id];
		}
		let _g13 = result2;
		let _this2 = character.inapplicableStatesRefs;
		let result3 = new Array(_this2.length);
		let _g14 = 0;
		let _g15 = _this2.length;
		while(_g14 < _g15) {
			let i = _g14++;
			result3[i] = statesById[_this2[i].ref];
		}
		return new bunga_Character(_g10,_g13,result3);
	}
	static toSdd(character,extraFields,mediaObjects) {
		let _this = character.states;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = bunga_State.toSdd(_this[i]);
		}
		let statesData = result;
		let result1 = new Array(statesData.length);
		let _g2 = 0;
		let _g3 = statesData.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = statesData[i].state;
		}
		let states = result1;
		let _g4 = character.id;
		let _g5 = character.parentId;
		let _g6 = character.toRepresentation(extraFields);
		let _g7 = states;
		let _this1 = character.inapplicableStates;
		let result2 = new Array(_this1.length);
		let _g8 = 0;
		let _g9 = _this1.length;
		while(_g8 < _g9) {
			let i = _g8++;
			result2[i] = new sdd_StateRef(_this1[i].id);
		}
		let _g10 = new sdd_Character(_g4,_g5,_g6,_g7,result2,Reflect.fields(character.children));
		let _g11 = states;
		let _g12 = [];
		let _g_current = 0;
		let _g_array = statesData;
		while(_g_current < _g_array.length) {
			let x = _g_array[_g_current++];
			_g12.push(x.mediaObjects);
		}
		let _g13 = [];
		let e = $getIterator(_g12);
		while(e.hasNext()) {
			let e1 = e.next();
			let x = $getIterator(e1);
			while(x.hasNext()) {
				let x1 = x.next();
				_g13.push(x1);
			}
		}
		return new bunga_SddCharacterData(_g10,_g11,_g13.concat([]));
	}
	static create(characters,data) {
		let nextId = Reflect.fields(characters).length;
		while(characters["myd-" + nextId] != null) ++nextId;
		let newCharacterId = "myd-" + nextId;
		return new bunga_Character(new bunga_HierarchicalItem("character",newCharacterId,newCharacterId,data.parentId,data.parentId == null,[],new bunga_DetailData(data.name,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null)),data.states,data.inapplicableStates);
	}
}
$hx_exports["bunga"]["Character"] = bunga_Character;
bunga_Character.__name__ = "bunga.Character";
Object.assign(bunga_Character.prototype, {
	__class__: bunga_Character
});
class bunga_CodedHierarchicalItem extends bunga_Item {
	constructor(item) {
		if(bunga_DetailData._hx_skip_constructor) {
			super();
			return;
		}
		bunga_DetailData._hx_skip_constructor = true;
		super();
		bunga_DetailData._hx_skip_constructor = false;
		this._hx_constructor(item);
	}
	_hx_constructor(item) {
		this.children = [];
		super._hx_constructor(item.id,new bunga_DetailData(item.name,item.author,item.nameCN,item.fasc,item.page,item.detail,item.photos,null,item.name2,item.vernacularName,item.vernacularName2,item.meaning,item.noHerbier,item.website,item.herbariumPicture,item.extra));
		this.type = item.type;
		this.hid = item.hid;
		this.parentId = item.parentId;
		this.topLevel = item.topLevel;
		let access = item.children;
		let _g_access = access;
		let _g_keys = Reflect.fields(access);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let child = _g_access[_g_keys[_g_index++]];
			if(child == null) {
				console.log("src/bunga/Codec.hx:22:",item.name + " has null child");
				console.log("src/bunga/Codec.hx:23:",item);
			} else {
				this.children.push(child.id);
			}
		}
	}
}
bunga_CodedHierarchicalItem.__name__ = "bunga.CodedHierarchicalItem";
Object.assign(bunga_CodedHierarchicalItem.prototype, {
	__class__: bunga_CodedHierarchicalItem
});
class bunga_CodedDescription {
	constructor(descriptorId,statesIds) {
		this.descriptorId = descriptorId;
		this.statesIds = statesIds;
	}
}
bunga_CodedDescription.__name__ = "bunga.CodedDescription";
Object.assign(bunga_CodedDescription.prototype, {
	__class__: bunga_CodedDescription
});
class bunga_CodedTaxon extends bunga_CodedHierarchicalItem {
	constructor(taxon) {
		bunga_DetailData._hx_skip_constructor = true;
		super();
		bunga_DetailData._hx_skip_constructor = false;
		this._hx_constructor(taxon);
	}
	_hx_constructor(taxon) {
		this.bookInfoByIds = { };
		super._hx_constructor(taxon);
		this.bookInfoByIds = taxon.bookInfoByIds;
		let _this = taxon.descriptions;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let d = _this[i];
			let d1 = d.descriptor.id;
			let _this1 = d.states;
			let result1 = new Array(_this1.length);
			let _g1 = 0;
			let _g2 = _this1.length;
			while(_g1 < _g2) {
				let i = _g1++;
				result1[i] = _this1[i].id;
			}
			result[i] = new bunga_CodedDescription(d1,result1);
		}
		this.descriptions = result;
	}
}
bunga_CodedTaxon.__name__ = "bunga.CodedTaxon";
Object.assign(bunga_CodedTaxon.prototype, {
	__class__: bunga_CodedTaxon
});
class bunga_CodedCharacter extends bunga_CodedHierarchicalItem {
	constructor(character) {
		super(character);
		let _this = character.states;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].id;
		}
		this.states = result;
		let _this1 = character.inapplicableStates;
		let result1 = new Array(_this1.length);
		let _g2 = 0;
		let _g3 = _this1.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = _this1[i].id;
		}
		this.inapplicableStatesIds = result1;
	}
}
bunga_CodedCharacter.__name__ = "bunga.CodedCharacter";
Object.assign(bunga_CodedCharacter.prototype, {
	__class__: bunga_CodedCharacter
});
class bunga_CodedDataset {
	constructor(dataset) {
		this.id = dataset.id;
		let _g = [];
		let access = dataset.taxons;
		let _g1_access = access;
		let _g1_keys = Reflect.fields(access);
		let _g1_index = 0;
		while(_g1_index < _g1_keys.length) {
			let taxon = _g1_access[_g1_keys[_g1_index++]];
			_g.push(new bunga_CodedTaxon(taxon));
		}
		this.taxons = _g;
		let _g1 = [];
		let access1 = dataset.descriptors;
		let _g3_access = access1;
		let _g3_keys = Reflect.fields(access1);
		let _g3_index = 0;
		while(_g3_index < _g3_keys.length) {
			let character = _g3_access[_g3_keys[_g3_index++]];
			_g1.push(new bunga_CodedCharacter(character));
		}
		this.descriptors = _g1;
		this.states = bunga_CodedDataset.getAllStates(dataset);
		this.books = dataset.books;
		this.extraFields = dataset.extraFields;
		this.dictionaryEntries = dataset.dictionaryEntries;
	}
	static getAllStates(dataset) {
		let states = [];
		let access = dataset.descriptors;
		let _g_access = access;
		let _g_keys = Reflect.fields(access);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let character = _g_access[_g_keys[_g_index++]];
			states = states.concat(character.states);
		}
		return states;
	}
}
bunga_CodedDataset.__name__ = "bunga.CodedDataset";
Object.assign(bunga_CodedDataset.prototype, {
	__class__: bunga_CodedDataset
});
class bunga_Codec {
	static decodeHierarchicalItem(item) {
		let item1 = new bunga_HierarchicalItem(item.type,item.id,item.hid,item.parentId,item.topLevel,item.children,item);
		return item1;
	}
	static decodeTaxon(taxon,descriptions,states,books) {
		let bookInfoByIds = taxon.bookInfoByIds != null ? taxon.bookInfoByIds : { };
		if(Reflect.fields(bookInfoByIds).length == 0) {
			let _g = 0;
			let _g1 = bunga_Book.standard;
			while(_g < _g1.length) {
				let book = _g1[_g];
				++_g;
				let info = new bunga_BookInfo(book.id == "fmc" ? "" + taxon.fasc : "",book.id == "fmc" ? taxon.page : null,"");
				bookInfoByIds[book.id] = info;
			}
		}
		let _g = bunga_Codec.decodeHierarchicalItem(taxon);
		let _g1 = bookInfoByIds;
		let _this = taxon.descriptions;
		let result = new Array(_this.length);
		let _g2 = 0;
		let _g3 = _this.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let d = _this[i];
			let _g = descriptions[d.descriptorId];
			let _this1 = d.statesIds;
			let result1 = new Array(_this1.length);
			let _g1 = 0;
			let _g3 = _this1.length;
			while(_g1 < _g3) {
				let i = _g1++;
				result1[i] = states[_this1[i]];
			}
			result[i] = new bunga_Description(_g,result1);
		}
		return new bunga_Taxon(_g,result,_g1);
	}
	static decodeCharacter(character,states) {
		let _g = bunga_Codec.decodeHierarchicalItem(character);
		let _this = character.states;
		let result = new Array(_this.length);
		let _g1 = 0;
		let _g2 = _this.length;
		while(_g1 < _g2) {
			let i = _g1++;
			result[i] = states[_this[i]];
		}
		let _g3 = result;
		let tmp;
		if(character.inapplicableStates != null) {
			let _this = character.inapplicableStates;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = states[_this[i].id];
			}
			tmp = result;
		} else {
			let _this = character.inapplicableStatesIds;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = states[_this[i]];
			}
			tmp = result;
		}
		return new bunga_Character(_g,_g3,tmp);
	}
	static encodeDataset(dataset) {
		return new bunga_CodedDataset(dataset);
	}
	static decodeDataset(dataset) {
		let states = { };
		let descriptors = { };
		let taxons = { };
		let _g = [];
		let _g1 = 0;
		let _g2 = bunga_Book.standard;
		while(_g1 < _g2.length) {
			let book = _g2[_g1];
			++_g1;
			_g.push(book);
		}
		let books = _g;
		let _g3 = 0;
		let _g4 = dataset.states;
		while(_g3 < _g4.length) {
			let state = _g4[_g3];
			++_g3;
			states[state.id] = state;
		}
		let _g5 = 0;
		let _g6 = dataset.descriptors;
		while(_g5 < _g6.length) {
			let descriptor = _g6[_g5];
			++_g5;
			descriptors[descriptor.id] = bunga_Codec.decodeCharacter(descriptor,states);
		}
		let _g7 = 0;
		let _g8 = dataset.taxons;
		while(_g7 < _g8.length) {
			let taxon = _g8[_g7];
			++_g7;
			taxons[taxon.id] = bunga_Codec.decodeTaxon(taxon,descriptors,states,books);
		}
		let access = descriptors;
		let _g9_access = access;
		let _g9_keys = Reflect.fields(access);
		let _g9_index = 0;
		while(_g9_index < _g9_keys.length) {
			let descriptor = _g9_access[_g9_keys[_g9_index++]];
			descriptor.hydrateChildren(descriptors);
		}
		let access1 = taxons;
		let _g10_access = access1;
		let _g10_keys = Reflect.fields(access1);
		let _g10_index = 0;
		while(_g10_index < _g10_keys.length) {
			let taxon = _g10_access[_g10_keys[_g10_index++]];
			taxon.hydrateChildren(taxons);
		}
		return new bunga_Dataset(dataset.id,taxons,descriptors,books,dataset.extraFields,dataset.dictionaryEntries);
	}
}
$hx_exports["bunga"]["Codec"] = bunga_Codec;
bunga_Codec.__name__ = "bunga.Codec";
class bunga_Dataset {
	constructor(id,taxons,descriptors,books,extraFields,dictionaryEntries) {
		this.id = "0";
		this.taxons = taxons;
		this.descriptors = descriptors;
		let tmp;
		if(books != null) {
			tmp = books;
		} else {
			let _g = [];
			let _g1 = 0;
			let _g2 = bunga_Book.standard;
			while(_g1 < _g2.length) {
				let book = _g2[_g1];
				++_g1;
				_g.push(book);
			}
			tmp = _g;
		}
		this.books = tmp;
		this.extraFields = extraFields != null ? extraFields : [];
		this.dictionaryEntries = dictionaryEntries != null ? dictionaryEntries : { };
	}
	static extractStatesById(sddContent,photosByRef) {
		let statesById = { };
		let _g = 0;
		let _g1 = sddContent.states;
		while(_g < _g1.length) {
			let state = _g1[_g];
			++_g;
			statesById[state.id] = bunga_State.fromSdd(state,photosByRef);
		}
		return statesById;
	}
	static extractItemsById(sddContent,descriptors,extraFields,statesById,photosByRef) {
		let itemsById = { };
		let _g = 0;
		let _g1 = sddContent.taxons;
		while(_g < _g1.length) {
			let taxon = _g1[_g];
			++_g;
			itemsById[taxon.id] = bunga_Taxon.fromSdd(taxon,extraFields,photosByRef,descriptors,statesById);
		}
		return itemsById;
	}
	static extractDescriptorsById(sddContent,statesById,photosByRef) {
		let descriptorsById = { };
		let _g = 0;
		let _g1 = sddContent.characters;
		while(_g < _g1.length) {
			let character = _g1[_g];
			++_g;
			descriptorsById[character.id] = bunga_Character.fromSdd(character,photosByRef,statesById);
		}
		return descriptorsById;
	}
	static extractPhotosByRef(sddContent) {
		let photosByRef = { };
		let _g = 0;
		let _g1 = sddContent.mediaObjects;
		while(_g < _g1.length) {
			let mediaObject = _g1[_g];
			++_g;
			photosByRef[mediaObject.id] = mediaObject.source;
		}
		return photosByRef;
	}
	static fromSdd(dataset,extraFields) {
		let photosByRef = bunga_Dataset.extractPhotosByRef(dataset);
		let statesById = bunga_Dataset.extractStatesById(dataset,photosByRef);
		let descriptors = bunga_Dataset.extractDescriptorsById(dataset,statesById,photosByRef);
		let access = descriptors;
		let _g_access = access;
		let _g_keys = Reflect.fields(access);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let descriptor = _g_access[_g_keys[_g_index++]];
			descriptor.hydrateChildren(descriptors);
		}
		let taxons = bunga_Dataset.extractItemsById(dataset,descriptors,extraFields,statesById,photosByRef);
		let access1 = taxons;
		let _g1_access = access1;
		let _g1_keys = Reflect.fields(access1);
		let _g1_index = 0;
		while(_g1_index < _g1_keys.length) {
			let item = _g1_access[_g1_keys[_g1_index++]];
			item.hydrateChildren(taxons);
		}
		return new bunga_Dataset("0",taxons,descriptors,null,null,null);
	}
	static toSdd(dataset,extraFields) {
		let taxons = [];
		let characters = [];
		let states = [];
		let mediaObjects = [];
		let access = dataset.taxons;
		let _g_access = access;
		let _g_keys = Reflect.fields(access);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let taxon = _g_access[_g_keys[_g_index++]];
			let sddData = bunga_Taxon.toSdd(taxon,extraFields,mediaObjects);
			taxons.push(sddData.taxon);
			mediaObjects = mediaObjects.concat(sddData.mediaObjects);
		}
		let access1 = dataset.descriptors;
		let _g1_access = access1;
		let _g1_keys = Reflect.fields(access1);
		let _g1_index = 0;
		while(_g1_index < _g1_keys.length) {
			let character = _g1_access[_g1_keys[_g1_index++]];
			let sddData = bunga_Character.toSdd(character,extraFields,mediaObjects);
			characters.push(sddData.character);
			states = states.concat(sddData.states);
			mediaObjects = mediaObjects.concat(sddData.mediaObjects);
		}
		return new sdd_Dataset(taxons,characters,states,mediaObjects);
	}
}
$hx_exports["bunga"]["Dataset"] = bunga_Dataset;
bunga_Dataset.__name__ = "bunga.Dataset";
Object.assign(bunga_Dataset.prototype, {
	__class__: bunga_Dataset
});
class bunga_Description {
	constructor(descriptor,states) {
		this.descriptor = descriptor;
		this.states = states;
	}
}
bunga_Description.__name__ = "bunga.Description";
Object.assign(bunga_Description.prototype, {
	__class__: bunga_Description
});
class bunga_DetailHighlighter {
	constructor() {
		this.wordsToHighlight = [];
	}
	loadWordText(text) {
		let lines = text.split("\n");
		let _g = 0;
		while(_g < lines.length) {
			let line = lines[_g];
			++_g;
			let words = line.split(",");
			let _g1 = 0;
			while(_g1 < words.length) {
				let word = words[_g1];
				++_g1;
				this.wordsToHighlight.push(StringTools.trim(word));
			}
		}
	}
	highlightTaxons(taxons) {
		let _this = this.wordsToHighlight;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = bunga_ERegTools.escape(_this[i]);
		}
		let reTxt = result.join("|");
		let re_r = new RegExp("([^\\w<>]|^|<p>)(" + reTxt + ")([^\\w<>]|$|</p>)","g".split("u").join(""));
		let access = taxons;
		let _g_access = access;
		let _g_keys = Reflect.fields(access);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let taxon = _g_access[_g_keys[_g_index++]];
			taxon.detail = taxon.detail.replace(re_r,"$1<b>$2</b>$3");
		}
	}
}
$hx_exports["bunga"]["DetailHighlighter"] = bunga_DetailHighlighter;
bunga_DetailHighlighter.__name__ = "bunga.DetailHighlighter";
Object.assign(bunga_DetailHighlighter.prototype, {
	__class__: bunga_DetailHighlighter
});
class bunga_ERegTools {
	static escape(string) {
		let _this_r = new RegExp("[.*+?^${}()|[\\]\\\\]","g".split("u").join(""));
		return string.replace(_this_r,"\\$&");
	}
}
bunga_ERegTools.__name__ = "bunga.ERegTools";
class bunga_Field {
	constructor(std,id,label) {
		this.std = std;
		this.id = id;
		this.label = label;
	}
}
bunga_Field.__name__ = "bunga.Field";
Object.assign(bunga_Field.prototype, {
	__class__: bunga_Field
});
class bunga_FileNameGenerator {
	static generate(name) {
		let generatedName = name;
		let _g = 0;
		let _g1 = bunga_FileNameGenerator.forbiddenChars;
		while(_g < _g1.length) {
			let char = _g1[_g];
			++_g;
			generatedName = StringTools.replace(generatedName,char,"_");
		}
		return generatedName;
	}
}
bunga_FileNameGenerator.__name__ = "bunga.FileNameGenerator";
class bunga_Hierarchy {
	static getEntries(hierarchy,entries,path) {
		if(path == null) {
			path = "";
		}
		if(hierarchy == null) {
			return new haxe_ds_List();
		}
		if(entries == null) {
			entries = new haxe_ds_List();
		}
		let content = haxe_io_Bytes.ofString("");
		let access = hierarchy;
		let _g_access = access;
		let _g_keys = Reflect.fields(access);
		let _g_index = 0;
		while(_g_index < _g_keys.length) {
			let entry = _g_access[_g_keys[_g_index++]];
			if(entry.topLevel || path != "") {
				let entryName = bunga_FileNameGenerator.generate(entry.name);
				let currentPath = path + encodeURIComponent(entryName) + "/";
				entries.push({ fileName : currentPath, fileSize : content.length, fileTime : new Date(), compressed : false, dataSize : 0, data : content, crc32 : haxe_crypto_Crc32.make(content)});
				bunga_Hierarchy.getEntries(entry.children,entries,currentPath);
			}
		}
		return entries;
	}
	static toZip(hierarchy) {
		let entries = bunga_Hierarchy.getEntries(hierarchy);
		let bytes = new haxe_io_BytesOutput();
		let writer = new haxe_zip_Writer(bytes);
		writer.write(entries);
		return bytes.getBytes().b.bufferValue;
	}
}
$hx_exports["bunga"]["Hierarchy"] = bunga_Hierarchy;
bunga_Hierarchy.__name__ = "bunga.Hierarchy";
class bunga_ImageCache {
	constructor() {
		this.cache = new haxe_ds_StringMap();
	}
	createStore(db) {
		if(!db.objectStoreNames.contains("ImageCache")) {
			db.createObjectStore("ImageCache",{ keyPath : "url"});
		}
	}
	dbStore(url,blob) {
		let rq = window.indexedDB.open("ImageCache",1);
		let _gthis = this;
		rq.onupgradeneeded = function() {
			_gthis.createStore(rq.result);
		};
		rq.onerror = function() {
			console.log("src/bunga/ImageCache.hx:38:","Impossible to store data on your browser.");
		};
		rq.onsuccess = function() {
			let db = rq.result;
			let transaction = db.transaction("ImageCache","readwrite");
			transaction.oncomplete = function() {
				console.log("src/bunga/ImageCache.hx:47:","Write for URL #" + url + " successful");
			};
			let ImageCache = transaction.objectStore("ImageCache");
			ImageCache.put({ url : url, image : blob});
		};
	}
	dbList() {
		let _gthis = this;
		return new Promise(function(resolve,reject) {
			let rq = window.indexedDB.open("ImageCache",1);
			rq.onupgradeneeded = function() {
				_gthis.createStore(rq.result);
			};
			rq.onsuccess = function() {
				let db = rq.result;
				let transaction = db.transaction("ImageCache","readonly");
				transaction.oncomplete = function() {
					console.log("src/bunga/ImageCache.hx:69:","Listing ImageCache URLs successful");
				};
				let imageCache = transaction.objectStore("ImageCache");
				let list = imageCache.getAll();
				list.onsuccess = function() {
					resolve(list.result);
				};
				list.onerror = function() {
					console.log("src/bunga/ImageCache.hx:80:","Listing ImageCache URLs failed.");
					reject(rq.result);
				};
			};
			rq.onerror = function() {
				reject(rq.result);
			};
		});
	}
	dbLoad(id) {
		let _gthis = this;
		return new Promise(function(resolve,reject) {
			let rq = window.indexedDB.open("ImageCache",1);
			rq.onupgradeneeded = function() {
				_gthis.createStore(rq.result);
			};
			rq.onsuccess = function() {
				let db = rq.result;
				let transaction = db.transaction("ImageCache","readonly");
				transaction.oncomplete = function() {
					console.log("src/bunga/ImageCache.hx:103:","Read from dataset #" + id + " successful");
				};
				let ImageCache = transaction.objectStore("ImageCache");
				let read = ImageCache.get(id);
				read.onsuccess = function() {
					resolve(read.result);
				};
				read.onerror = function() {
					console.log("src/bunga/ImageCache.hx:113:","Read from dataset #" + id + " failed");
					reject(read.result);
				};
			};
			rq.onerror = function() {
				reject(rq.result);
			};
		});
	}
	initFromDatabase() {
		let _gthis = this;
		return this.dbList().then(function(data) {
			let _g = 0;
			while(_g < data.length) {
				let entry = data[_g];
				++_g;
				_gthis.cache.h[entry.url] = entry.blob;
			}
		});
	}
	addFromUrl(url) {
		let rq = new XMLHttpRequest();
		let _gthis = this;
		rq.open("GET",url);
		rq.responseType = "blob";
		rq.onload = function(data) {
			_gthis.cache.h[url] = rq.response;
			console.log("src/bunga/ImageCache.hx:137:",rq.response);
		};
		rq.send();
	}
	get(url) {
		return this.cache.h[url];
	}
}
$hx_exports["bunga"]["ImageCache"] = bunga_ImageCache;
bunga_ImageCache.__name__ = "bunga.ImageCache";
Object.assign(bunga_ImageCache.prototype, {
	__class__: bunga_ImageCache
});
class bunga_SddStateData {
	constructor(state,mediaObjects) {
		this.state = state;
		this.mediaObjects = mediaObjects;
	}
}
bunga_SddStateData.__name__ = "bunga.SddStateData";
Object.assign(bunga_SddStateData.prototype, {
	__class__: bunga_SddStateData
});
class bunga_State {
	constructor(id,descriptorId,name,photos) {
		this.id = id;
		this.descriptorId = descriptorId;
		this.name = name;
		this.photos = photos;
	}
	static fromSdd(state,photosByRef) {
		let _g = state.id;
		let _g1 = state.characterId;
		let _g2 = state.label;
		let _this = state.mediaObjectsRefs;
		let result = new Array(_this.length);
		let _g3 = 0;
		let _g4 = _this.length;
		while(_g3 < _g4) {
			let i = _g3++;
			result[i] = photosByRef[_this[i].ref];
		}
		return new bunga_State(_g,_g1,_g2,result);
	}
	static toSdd(state) {
		return new bunga_SddStateData(new sdd_State(state.id,state.descriptorId,new sdd_Representation(state.name,"",[])),[]);
	}
}
bunga_State.__name__ = "bunga.State";
Object.assign(bunga_State.prototype, {
	__class__: bunga_State
});
class bunga_SddTaxonData {
	constructor(taxon,mediaObjects) {
		this.taxon = taxon;
		this.mediaObjects = mediaObjects;
	}
}
bunga_SddTaxonData.__name__ = "bunga.SddTaxonData";
Object.assign(bunga_SddTaxonData.prototype, {
	__class__: bunga_SddTaxonData
});
class bunga_Taxon extends bunga_HierarchicalItem {
	constructor(item,descriptions,bookInfoByIds) {
		bunga_DetailData._hx_skip_constructor = true;
		super();
		bunga_DetailData._hx_skip_constructor = false;
		this._hx_constructor(item,descriptions,bookInfoByIds);
	}
	_hx_constructor(item,descriptions,bookInfoByIds) {
		this.bookInfoByIds = { };
		super._hx_constructor("taxon",item.id,item.hid,item.parentId,item.topLevel,Reflect.fields(item.children),item);
		this.descriptions = descriptions;
		if(bookInfoByIds != null) {
			this.bookInfoByIds = bookInfoByIds;
		}
	}
	static fromSdd(taxon,extraFields,photosByRef,descriptors,statesById) {
		let descriptions_h = Object.create(null);
		let _g = 0;
		let _g1 = taxon.categoricals;
		while(_g < _g1.length) {
			let categorical = _g1[_g];
			++_g;
			let _g2 = descriptors[categorical.ref];
			let _this = categorical.stateRefs;
			let result = new Array(_this.length);
			let _g3 = 0;
			let _g4 = _this.length;
			while(_g3 < _g4) {
				let i = _g3++;
				result[i] = statesById[_this[i].ref];
			}
			let description = new bunga_Description(_g2,result);
			descriptions_h[categorical.ref] = description;
		}
		let _g2 = taxon.id;
		let _g3 = taxon.id;
		let _g4 = taxon.parentId;
		let _g5 = taxon.parentId == null;
		let _g6 = taxon.childrenIds;
		let photosByRef1 = photosByRef;
		let names = taxon.label.split("/");
		let name = names[0];
		let author = names[1];
		let nameCN = names[2];
		let fields = bunga_Field.standard.concat(extraFields);
		let floreRe = new EReg("Flore Madagascar et Comores\\s*<br>\\s*fasc\\s+(\\d*)\\s*<br>\\s*page\\s+(null|\\d*)","i");
		let fasc = null;
		let page = null;
		if(floreRe.match(taxon.detail)) {
			fasc = Std.parseInt(floreRe.matched(1));
			page = Std.parseInt(floreRe.matched(2));
		}
		let taxon1 = taxon.detail;
		let result = new Array(fields.length);
		let _g7 = 0;
		let _g8 = fields.length;
		while(_g7 < _g8) {
			let i = _g7++;
			result[i] = fields[i].label;
		}
		let detail = bunga_DetailData.removeFromDescription(taxon1,result).replace(floreRe.r,"");
		let emptyParagraphRe = new EReg("<p>(\n|\t|\\s|<br>|&nbsp;)*</p>","gi");
		if(emptyParagraphRe.match(detail)) {
			detail = detail.replace(emptyParagraphRe.r,"");
		}
		let _this = taxon.mediaObjectsRefs;
		let result1 = new Array(_this.length);
		let _g9 = 0;
		let _g10 = _this.length;
		while(_g9 < _g10) {
			let i = _g9++;
			result1[i] = photosByRef1[_this[i].ref];
		}
		let photos = result1;
		let data = new bunga_DetailData(name,author,nameCN,fasc,page,detail,photos,extraFields,null,null,null,null,null,null,null,null);
		let _g11 = 0;
		while(_g11 < fields.length) {
			let field = fields[_g11];
			++_g11;
			(field.std ? data : data.extra)[field.id] = bunga_DetailData.findInDescription(taxon.detail,field.label);
		}
		let _g12 = new bunga_HierarchicalItem("taxon",_g2,_g3,_g4,_g5,_g6,data);
		let _g13 = [];
		let _g14 = haxe_ds_StringMap.kvIterator(descriptions_h);
		while(_g14.hasNext()) {
			let _g = _g14.next();
			let _ = _g.key;
			let value = _g.value;
			_g13.push(value);
		}
		return new bunga_Taxon(_g12,_g13,null);
	}
	static toSdd(taxon,extraFields,mediaObjects) {
		let _g = taxon.id;
		let _g1 = taxon.parentId;
		let _g2 = taxon.toRepresentation(extraFields);
		let _g3 = Reflect.fields(taxon.children);
		let _this = taxon.descriptions;
		let result = new Array(_this.length);
		let _g4 = 0;
		let _g5 = _this.length;
		while(_g4 < _g5) {
			let i = _g4++;
			let d = _this[i];
			let _g = d.descriptor.id;
			let _this1 = d.states;
			let result1 = new Array(_this1.length);
			let _g1 = 0;
			let _g2 = _this1.length;
			while(_g1 < _g2) {
				let i = _g1++;
				result1[i] = new sdd_StateRef(_this1[i].id);
			}
			result[i] = new sdd_CategoricalRef(_g,result1);
		}
		let sddTaxon = new sdd_Taxon(_g,_g1,_g2,_g3,result);
		return new bunga_SddTaxonData(sddTaxon,[]);
	}
}
bunga_Taxon.__name__ = "bunga.Taxon";
Object.assign(bunga_Taxon.prototype, {
	__class__: bunga_Taxon
});
class bunga_TaxonToTex {
	constructor(taxons) {
		this.progressListeners = [];
		this.pictureNameByUrl = new haxe_ds_StringMap();
		this.photos = [];
		let _g = 0;
		while(_g < taxons.length) {
			let taxon = taxons[_g];
			++_g;
			if(taxon.photos.length > 0) {
				let photo = taxon.photos[0];
				let this1 = this.pictureNameByUrl;
				let value = bunga_FileNameGenerator.generate(taxon.name) + ".jpg";
				this1.h[photo] = value;
				this.photos.push(photo);
			}
		}
	}
	picture(resolve,urls) {
		return this.pictureNameByUrl.h[urls[0]];
	}
	onProgress(listener) {
		this.progressListeners.push(listener);
	}
	progressed(progress,progresMax) {
		let _g = 0;
		let _g1 = this.progressListeners;
		while(_g < _g1.length) {
			let listener = _g1[_g];
			++_g;
			listener(progress,progresMax);
		}
	}
	export(taxons) {
		let texTemplate = haxe_Resource.getString("tex_template");
		let _gthis = this;
		let template = new haxe_Template(texTemplate);
		let entries = new haxe_ds_List();
		let texFileContent = haxe_io_Bytes.ofString(template.execute({ taxons : taxons},this));
		entries.push({ fileName : "latex/export.tex", fileSize : texFileContent.length, fileTime : new Date(), compressed : false, dataSize : 0, data : texFileContent, crc32 : haxe_crypto_Crc32.make(texFileContent)});
		return new Promise(function(resolve,reject) {
			let semaphore = _gthis.photos.length;
			let semDec = function() {
				semaphore -= 1;
				_gthis.progressed(_gthis.photos.length - semaphore,_gthis.photos.length);
				if(semaphore == 0) {
					let bytes = new haxe_io_BytesOutput();
					let writer = new haxe_zip_Writer(bytes);
					writer.write(entries);
					resolve(bytes.getBytes().b.bufferValue);
				}
			};
			let _g = 0;
			let _g1 = _gthis.photos;
			while(_g < _g1.length) {
				let photo = _g1[_g];
				++_g;
				let rq = new haxe_http_HttpJs(photo);
				rq.onBytes = function(bytes) {
					entries.push({ fileName : "latex/" + _gthis.pictureNameByUrl.h[photo], fileSize : bytes.length, fileTime : new Date(), compressed : false, dataSize : 0, data : bytes, crc32 : haxe_crypto_Crc32.make(bytes)});
					semDec();
				};
				rq.onError = function(msg) {
					console.log("src/bunga/TaxonToTex.hx:92:","error: " + msg);
					semDec();
				};
				rq.request(false);
			}
		});
	}
}
$hx_exports["bunga"]["TaxonToTex"] = bunga_TaxonToTex;
bunga_TaxonToTex.__name__ = "bunga.TaxonToTex";
Object.assign(bunga_TaxonToTex.prototype, {
	__class__: bunga_TaxonToTex
});
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = "haxe.Exception";
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
	,__properties__: {get_native: "get_native",get_message: "get_message"}
});
class haxe_Resource {
	static getString(name) {
		let _g = 0;
		let _g1 = haxe_Resource.content;
		while(_g < _g1.length) {
			let x = _g1[_g];
			++_g;
			if(x.name == name) {
				if(x.str != null) {
					return x.str;
				}
				let b = haxe_crypto_Base64.decode(x.data);
				return b.toString();
			}
		}
		return null;
	}
}
haxe_Resource.__name__ = "haxe.Resource";
var haxe__$Template_TemplateExpr = $hxEnums["haxe._Template.TemplateExpr"] = { __ename__ : true, __constructs__ : ["OpVar","OpExpr","OpIf","OpStr","OpBlock","OpForeach","OpMacro"]
	,OpVar: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["v"],$_)
	,OpExpr: ($_=function(expr) { return {_hx_index:1,expr:expr,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["expr"],$_)
	,OpIf: ($_=function(expr,eif,eelse) { return {_hx_index:2,expr:expr,eif:eif,eelse:eelse,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["expr","eif","eelse"],$_)
	,OpStr: ($_=function(str) { return {_hx_index:3,str:str,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["str"],$_)
	,OpBlock: ($_=function(l) { return {_hx_index:4,l:l,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["l"],$_)
	,OpForeach: ($_=function(expr,loop) { return {_hx_index:5,expr:expr,loop:loop,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["expr","loop"],$_)
	,OpMacro: ($_=function(name,params) { return {_hx_index:6,name:name,params:params,__enum__:"haxe._Template.TemplateExpr",toString:$estr}; },$_.__params__ = ["name","params"],$_)
};
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class haxe_Template {
	constructor(str) {
		let tokens = this.parseTokens(str);
		this.expr = this.parseBlock(tokens);
		if(!tokens.isEmpty()) {
			throw haxe_Exception.thrown("Unexpected '" + Std.string(tokens.first().s) + "'");
		}
	}
	execute(context,macros) {
		this.macros = macros == null ? { } : macros;
		this.context = context;
		this.stack = new haxe_ds_List();
		this.buf = new StringBuf();
		this.run(this.expr);
		return this.buf.b;
	}
	resolve(v) {
		if(v == "__current__") {
			return this.context;
		}
		let value = Reflect.getProperty(this.context,v);
		if(value != null || Object.prototype.hasOwnProperty.call(this.context,v)) {
			return value;
		}
		let _g_head = this.stack.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			let ctx = val;
			value = Reflect.getProperty(ctx,v);
			if(value != null || Object.prototype.hasOwnProperty.call(ctx,v)) {
				return value;
			}
		}
		return Reflect.field(haxe_Template.globals,v);
	}
	parseTokens(data) {
		let tokens = new haxe_ds_List();
		while(haxe_Template.splitter.match(data)) {
			let p = haxe_Template.splitter.matchedPos();
			if(p.pos > 0) {
				tokens.add({ p : HxOverrides.substr(data,0,p.pos), s : true, l : null});
			}
			if(HxOverrides.cca(data,p.pos) == 58) {
				tokens.add({ p : HxOverrides.substr(data,p.pos + 2,p.len - 4), s : false, l : null});
				data = haxe_Template.splitter.matchedRight();
				continue;
			}
			let parp = p.pos + p.len;
			let npar = 1;
			let params = [];
			let part = "";
			while(true) {
				let c = HxOverrides.cca(data,parp);
				++parp;
				if(c == 40) {
					++npar;
				} else if(c == 41) {
					--npar;
					if(npar <= 0) {
						break;
					}
				} else if(c == null) {
					throw haxe_Exception.thrown("Unclosed macro parenthesis");
				}
				if(c == 44 && npar == 1) {
					params.push(part);
					part = "";
				} else {
					part += String.fromCodePoint(c);
				}
			}
			params.push(part);
			tokens.add({ p : haxe_Template.splitter.matched(2), s : false, l : params});
			data = HxOverrides.substr(data,parp,data.length - parp);
		}
		if(data.length > 0) {
			tokens.add({ p : data, s : true, l : null});
		}
		return tokens;
	}
	parseBlock(tokens) {
		let l = new haxe_ds_List();
		while(true) {
			let t = tokens.first();
			if(t == null) {
				break;
			}
			if(!t.s && (t.p == "end" || t.p == "else" || HxOverrides.substr(t.p,0,7) == "elseif ")) {
				break;
			}
			l.add(this.parse(tokens));
		}
		if(l.length == 1) {
			return l.first();
		}
		return haxe__$Template_TemplateExpr.OpBlock(l);
	}
	parse(tokens) {
		let t = tokens.pop();
		let p = t.p;
		if(t.s) {
			return haxe__$Template_TemplateExpr.OpStr(p);
		}
		if(t.l != null) {
			let pe = new haxe_ds_List();
			let _g = 0;
			let _g1 = t.l;
			while(_g < _g1.length) {
				let p = _g1[_g];
				++_g;
				pe.add(this.parseBlock(this.parseTokens(p)));
			}
			return haxe__$Template_TemplateExpr.OpMacro(p,pe);
		}
		let kwdEnd = function(kwd) {
			let pos = -1;
			let length = kwd.length;
			if(HxOverrides.substr(p,0,length) == kwd) {
				pos = length;
				let _g_offset = 0;
				let _g_s = HxOverrides.substr(p,length,null);
				while(_g_offset < _g_s.length) {
					let c = _g_s.charCodeAt(_g_offset++);
					if(c == 32) {
						++pos;
					} else {
						break;
					}
				}
			}
			return pos;
		};
		let pos = kwdEnd("if");
		if(pos > 0) {
			p = HxOverrides.substr(p,pos,p.length - pos);
			let e = this.parseExpr(p);
			let eif = this.parseBlock(tokens);
			let t = tokens.first();
			let eelse;
			if(t == null) {
				throw haxe_Exception.thrown("Unclosed 'if'");
			}
			if(t.p == "end") {
				tokens.pop();
				eelse = null;
			} else if(t.p == "else") {
				tokens.pop();
				eelse = this.parseBlock(tokens);
				t = tokens.pop();
				if(t == null || t.p != "end") {
					throw haxe_Exception.thrown("Unclosed 'else'");
				}
			} else {
				t.p = HxOverrides.substr(t.p,4,t.p.length - 4);
				eelse = this.parse(tokens);
			}
			return haxe__$Template_TemplateExpr.OpIf(e,eif,eelse);
		}
		let pos1 = kwdEnd("foreach");
		if(pos1 >= 0) {
			p = HxOverrides.substr(p,pos1,p.length - pos1);
			let e = this.parseExpr(p);
			let efor = this.parseBlock(tokens);
			let t = tokens.pop();
			if(t == null || t.p != "end") {
				throw haxe_Exception.thrown("Unclosed 'foreach'");
			}
			return haxe__$Template_TemplateExpr.OpForeach(e,efor);
		}
		if(haxe_Template.expr_splitter.match(p)) {
			return haxe__$Template_TemplateExpr.OpExpr(this.parseExpr(p));
		}
		return haxe__$Template_TemplateExpr.OpVar(p);
	}
	parseExpr(data) {
		let l = new haxe_ds_List();
		let expr = data;
		while(haxe_Template.expr_splitter.match(data)) {
			let p = haxe_Template.expr_splitter.matchedPos();
			let k = p.pos + p.len;
			if(p.pos != 0) {
				l.add({ p : HxOverrides.substr(data,0,p.pos), s : true});
			}
			let p1 = haxe_Template.expr_splitter.matched(0);
			l.add({ p : p1, s : p1.indexOf("\"") >= 0});
			data = haxe_Template.expr_splitter.matchedRight();
		}
		if(data.length != 0) {
			let _g_offset = 0;
			let _g_s = data;
			while(_g_offset < _g_s.length) {
				let _g1_key = _g_offset;
				let _g1_value = _g_s.charCodeAt(_g_offset++);
				let i = _g1_key;
				let c = _g1_value;
				if(c != 32) {
					l.add({ p : HxOverrides.substr(data,i,null), s : true});
					break;
				}
			}
		}
		let e;
		try {
			e = this.makeExpr(l);
			if(!l.isEmpty()) {
				throw haxe_Exception.thrown(l.first().p);
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(typeof(_g1) == "string") {
				let s = _g1;
				throw haxe_Exception.thrown("Unexpected '" + s + "' in " + expr);
			} else {
				throw _g;
			}
		}
		return function() {
			try {
				return e();
			} catch( _g ) {
				let exc = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Error : " + Std.string(exc) + " in " + expr);
			}
		};
	}
	makeConst(v) {
		haxe_Template.expr_trim.match(v);
		v = haxe_Template.expr_trim.matched(1);
		if(HxOverrides.cca(v,0) == 34) {
			let str = HxOverrides.substr(v,1,v.length - 2);
			return function() {
				return str;
			};
		}
		if(haxe_Template.expr_int.match(v)) {
			let i = Std.parseInt(v);
			return function() {
				return i;
			};
		}
		if(haxe_Template.expr_float.match(v)) {
			let f = parseFloat(v);
			return function() {
				return f;
			};
		}
		let me = this;
		return function() {
			return me.resolve(v);
		};
	}
	makePath(e,l) {
		let p = l.first();
		if(p == null || p.p != ".") {
			return e;
		}
		l.pop();
		let field = l.pop();
		if(field == null || !field.s) {
			throw haxe_Exception.thrown(field.p);
		}
		let f = field.p;
		haxe_Template.expr_trim.match(f);
		f = haxe_Template.expr_trim.matched(1);
		return this.makePath(function() {
			return Reflect.field(e(),f);
		},l);
	}
	makeExpr(l) {
		return this.makePath(this.makeExpr2(l),l);
	}
	skipSpaces(l) {
		let p = l.first();
		while(p != null) {
			let _g_offset = 0;
			let _g_s = p.p;
			while(_g_offset < _g_s.length) {
				let c = _g_s.charCodeAt(_g_offset++);
				if(c != 32) {
					return;
				}
			}
			l.pop();
			p = l.first();
		}
	}
	makeExpr2(l) {
		this.skipSpaces(l);
		let p = l.pop();
		this.skipSpaces(l);
		if(p == null) {
			throw haxe_Exception.thrown("<eof>");
		}
		if(p.s) {
			return this.makeConst(p.p);
		}
		switch(p.p) {
		case "!":
			let e = this.makeExpr(l);
			return function() {
				let v = e();
				if(v != null) {
					return v == false;
				} else {
					return true;
				}
			};
		case "(":
			this.skipSpaces(l);
			let e1 = this.makeExpr(l);
			this.skipSpaces(l);
			let p1 = l.pop();
			if(p1 == null || p1.s) {
				throw haxe_Exception.thrown(p1);
			}
			if(p1.p == ")") {
				return e1;
			}
			this.skipSpaces(l);
			let e2 = this.makeExpr(l);
			this.skipSpaces(l);
			let p2 = l.pop();
			this.skipSpaces(l);
			if(p2 == null || p2.p != ")") {
				throw haxe_Exception.thrown(p2);
			}
			switch(p1.p) {
			case "!=":
				return function() {
					return e1() != e2();
				};
			case "&&":
				return function() {
					return e1() && e2();
				};
			case "*":
				return function() {
					return e1() * e2();
				};
			case "+":
				return function() {
					return e1() + e2();
				};
			case "-":
				return function() {
					return e1() - e2();
				};
			case "/":
				return function() {
					return e1() / e2();
				};
			case "<":
				return function() {
					return e1() < e2();
				};
			case "<=":
				return function() {
					return e1() <= e2();
				};
			case "==":
				return function() {
					return e1() == e2();
				};
			case ">":
				return function() {
					return e1() > e2();
				};
			case ">=":
				return function() {
					return e1() >= e2();
				};
			case "||":
				return function() {
					return e1() || e2();
				};
			default:
				throw haxe_Exception.thrown("Unknown operation " + p1.p);
			}
			break;
		case "-":
			let e3 = this.makeExpr(l);
			return function() {
				return -e3();
			};
		}
		throw haxe_Exception.thrown(p.p);
	}
	run(e) {
		switch(e._hx_index) {
		case 0:
			let v = e.v;
			let _this = this.buf;
			let x = Std.string(this.resolve(v));
			_this.b += Std.string(x);
			break;
		case 1:
			let e1 = e.expr;
			let _this1 = this.buf;
			let x1 = Std.string(e1());
			_this1.b += Std.string(x1);
			break;
		case 2:
			let eelse = e.eelse;
			let eif = e.eif;
			let e2 = e.expr;
			let v1 = e2();
			if(v1 == null || v1 == false) {
				if(eelse != null) {
					this.run(eelse);
				}
			} else {
				this.run(eif);
			}
			break;
		case 3:
			let str = e.str;
			this.buf.b += str == null ? "null" : "" + str;
			break;
		case 4:
			let l = e.l;
			let _g_head = l.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				let e = val;
				this.run(e);
			}
			break;
		case 5:
			let loop = e.loop;
			let e3 = e.expr;
			let v2 = e3();
			try {
				let x = $getIterator(v2);
				if(x.hasNext == null) {
					throw haxe_Exception.thrown(null);
				}
				v2 = x;
			} catch( _g ) {
				try {
					if(v2.hasNext == null) {
						throw haxe_Exception.thrown(null);
					}
				} catch( _g ) {
					throw haxe_Exception.thrown("Cannot iter on " + Std.string(v2));
				}
			}
			this.stack.push(this.context);
			let v3 = v2;
			let ctx = v3;
			while(ctx.hasNext()) {
				let ctx1 = ctx.next();
				this.context = ctx1;
				this.run(loop);
			}
			this.context = this.stack.pop();
			break;
		case 6:
			let params = e.params;
			let m = e.name;
			let v4 = Reflect.field(this.macros,m);
			let pl = [];
			let old = this.buf;
			pl.push($bind(this,this.resolve));
			let _g_head1 = params.h;
			while(_g_head1 != null) {
				let val = _g_head1.item;
				_g_head1 = _g_head1.next;
				let p = val;
				if(p._hx_index == 0) {
					let v = p.v;
					pl.push(this.resolve(v));
				} else {
					this.buf = new StringBuf();
					this.run(p);
					pl.push(this.buf.b);
				}
			}
			this.buf = old;
			try {
				let _this = this.buf;
				let x = Std.string(v4.apply(this.macros,pl));
				_this.b += Std.string(x);
			} catch( _g ) {
				let e = haxe_Exception.caught(_g).unwrap();
				let plstr;
				try {
					plstr = pl.join(",");
				} catch( _g ) {
					plstr = "???";
				}
				let msg = "Macro call " + m + "(" + plstr + ") failed (" + Std.string(e) + ")";
				throw haxe_Exception.thrown(msg);
			}
			break;
		}
	}
}
haxe_Template.__name__ = "haxe.Template";
Object.assign(haxe_Template.prototype, {
	__class__: haxe_Template
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = "haxe.ValueException";
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			let debug = pos > 0;
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let c2 = b[i++];
					let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let c2 = b[i++];
					let c3 = b[i++];
					let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	toString() {
		return this.getString(0,this.length);
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
	static ofData(b) {
		let hb = b.hxBytes;
		if(hb != null) {
			return hb;
		}
		return new haxe_io_Bytes(b);
	}
}
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
class haxe_crypto_Base64 {
	static decode(str,complement) {
		if(complement == null) {
			complement = true;
		}
		if(complement) {
			while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
		}
		return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
	}
}
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
class haxe_crypto_BaseCode {
	constructor(base) {
		let len = base.length;
		let nbits = 1;
		while(len > 1 << nbits) ++nbits;
		if(nbits > 8 || len != 1 << nbits) {
			throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
		}
		this.base = base;
		this.nbits = nbits;
	}
	initTable() {
		let tbl = [];
		let _g = 0;
		while(_g < 256) {
			let i = _g++;
			tbl[i] = -1;
		}
		let _g1 = 0;
		let _g2 = this.base.length;
		while(_g1 < _g2) {
			let i = _g1++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	decodeBytes(b) {
		let nbits = this.nbits;
		let base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		let tbl = this.tbl;
		let size = b.length * nbits >> 3;
		let out = new haxe_io_Bytes(new ArrayBuffer(size));
		let buf = 0;
		let curbits = 0;
		let pin = 0;
		let pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				let i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
}
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
Object.assign(haxe_crypto_BaseCode.prototype, {
	__class__: haxe_crypto_BaseCode
});
class haxe_crypto_Crc32 {
	static make(data) {
		let c_crc = -1;
		let b = data.b.bufferValue;
		let _g = 0;
		let _g1 = data.length;
		while(_g < _g1) {
			let i = _g++;
			let tmp = (c_crc ^ b.bytes[i]) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp;
		}
		return c_crc ^ -1;
	}
}
haxe_crypto_Crc32.__name__ = "haxe.crypto.Crc32";
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	push(item) {
		let x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	first() {
		if(this.h == null) {
			return null;
		} else {
			return this.h.item;
		}
	}
	pop() {
		if(this.h == null) {
			return null;
		}
		let x = this.h.item;
		this.h = this.h.next;
		if(this.h == null) {
			this.q = null;
		}
		this.length--;
		return x;
	}
	isEmpty() {
		return this.h == null;
	}
	toString() {
		let s_b = "";
		let first = true;
		let l = this.h;
		s_b += "{";
		while(l != null) {
			if(first) {
				first = false;
			} else {
				s_b += ", ";
			}
			s_b += Std.string(Std.string(l.item));
			l = l.next;
		}
		s_b += "}";
		return s_b;
	}
}
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	iterator() {
		return haxe_ds_StringMap.valueIterator(this.h);
	}
	static keysIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return keys[idx - 1];
		}};
	}
	static valueIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			return h[keys[idx - 1]];
		}};
	}
	static kvIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			let k = keys[idx - 1];
			return { key : k, value : h[k]};
		}};
	}
}
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_http_HttpBase {
	constructor(url) {
		if(haxe_http_HttpBase._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(url);
	}
	_hx_constructor(url) {
		this.url = url;
		this.headers = [];
		this.params = [];
		this.emptyOnData = $bind(this,this.onData);
	}
	onData(data) {
	}
	onBytes(data) {
	}
	onError(msg) {
	}
	onStatus(status) {
	}
	hasOnData() {
		return !Reflect.compareMethods($bind(this,this.onData),this.emptyOnData);
	}
	success(data) {
		this.responseBytes = data;
		this.responseAsString = null;
		if(this.hasOnData()) {
			this.onData(this.get_responseData());
		}
		this.onBytes(this.responseBytes);
	}
	get_responseData() {
		if(this.responseAsString == null && this.responseBytes != null) {
			this.responseAsString = this.responseBytes.getString(0,this.responseBytes.length,haxe_io_Encoding.UTF8);
		}
		return this.responseAsString;
	}
}
haxe_http_HttpBase.__name__ = "haxe.http.HttpBase";
Object.assign(haxe_http_HttpBase.prototype, {
	__class__: haxe_http_HttpBase
	,__properties__: {get_responseData: "get_responseData"}
});
class haxe_http_HttpJs extends haxe_http_HttpBase {
	constructor(url) {
		haxe_http_HttpBase._hx_skip_constructor = true;
		super();
		haxe_http_HttpBase._hx_skip_constructor = false;
		this._hx_constructor(url);
	}
	_hx_constructor(url) {
		this.async = true;
		this.withCredentials = false;
		super._hx_constructor(url);
	}
	request(post) {
		this.responseAsString = null;
		this.responseBytes = null;
		let r = this.req = js_Browser.createXMLHttpRequest();
		let _gthis = this;
		let onreadystatechange = function(_) {
			if(r.readyState != 4) {
				return;
			}
			let s;
			try {
				s = r.status;
			} catch( _g ) {
				s = null;
			}
			if(s == 0 && typeof(window) != "undefined" && $global.location != null) {
				let protocol = $global.location.protocol.toLowerCase();
				let rlocalProtocol = new EReg("^(?:about|app|app-storage|.+-extension|file|res|widget):$","");
				let isLocal = rlocalProtocol.match(protocol);
				if(isLocal) {
					s = r.response != null ? 200 : 404;
				}
			}
			if(s == undefined) {
				s = null;
			}
			if(s != null) {
				_gthis.onStatus(s);
			}
			if(s != null && s >= 200 && s < 400) {
				_gthis.req = null;
				_gthis.success(haxe_io_Bytes.ofData(r.response));
			} else if(s == null || s == 0 && r.response == null) {
				_gthis.req = null;
				_gthis.onError("Failed to connect or resolve host");
			} else if(s == null) {
				_gthis.req = null;
				let onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
				_gthis.responseBytes = onreadystatechange;
				_gthis.onError("Http Error #" + r.status);
			} else {
				switch(s) {
				case 12007:
					_gthis.req = null;
					_gthis.onError("Unknown host");
					break;
				case 12029:
					_gthis.req = null;
					_gthis.onError("Failed to connect to host");
					break;
				default:
					_gthis.req = null;
					let onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
					_gthis.responseBytes = onreadystatechange;
					_gthis.onError("Http Error #" + r.status);
				}
			}
		};
		if(this.async) {
			r.onreadystatechange = onreadystatechange;
		}
		let uri;
		let _g = this.postBytes;
		let _g1 = this.postData;
		if(_g1 == null) {
			if(_g == null) {
				uri = null;
			} else {
				let bytes = _g;
				uri = new Blob([bytes.b.bufferValue]);
			}
		} else if(_g == null) {
			let str = _g1;
			uri = str;
		} else {
			uri = null;
		}
		if(uri != null) {
			post = true;
		} else {
			let _g = 0;
			let _g1 = this.params;
			while(_g < _g1.length) {
				let p = _g1[_g];
				++_g;
				if(uri == null) {
					uri = "";
				} else {
					uri = (uri == null ? "null" : Std.string(uri)) + "&";
				}
				let s = p.name;
				let value = (uri == null ? "null" : Std.string(uri)) + encodeURIComponent(s) + "=";
				let s1 = p.value;
				uri = value + encodeURIComponent(s1);
			}
		}
		try {
			if(post) {
				r.open("POST",this.url,this.async);
			} else if(uri != null) {
				let question = this.url.split("?").length <= 1;
				r.open("GET",this.url + (question ? "?" : "&") + (uri == null ? "null" : Std.string(uri)),this.async);
				uri = null;
			} else {
				r.open("GET",this.url,this.async);
			}
			r.responseType = "arraybuffer";
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			this.req = null;
			this.onError(e.toString());
			return;
		}
		r.withCredentials = this.withCredentials;
		if(!Lambda.exists(this.headers,function(h) {
			return h.name == "Content-Type";
		}) && post && this.postData == null) {
			r.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		let _g2 = 0;
		let _g3 = this.headers;
		while(_g2 < _g3.length) {
			let h = _g3[_g2];
			++_g2;
			r.setRequestHeader(h.name,h.value);
		}
		r.send(uri);
		if(!this.async) {
			onreadystatechange(null);
		}
	}
}
haxe_http_HttpJs.__name__ = "haxe.http.HttpJs";
Object.assign(haxe_http_HttpJs.prototype, {
	__class__: haxe_http_HttpJs
});
class haxe_io_BytesBuffer {
	constructor() {
		this.pos = 0;
		this.size = 0;
	}
	addByte(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	addBytes(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		let sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	grow(delta) {
		let req = this.pos + delta;
		let nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		let nbuf = new ArrayBuffer(nsize);
		let nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	getBytes() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		let b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
}
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
Object.assign(haxe_io_BytesBuffer.prototype, {
	__class__: haxe_io_BytesBuffer
});
class haxe_io_Output {
	writeByte(c) {
		throw haxe_Exception.thrown("Not implemented");
	}
	writeBytes(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		let b = s.b;
		let k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	write(s) {
		let l = s.length;
		let p = 0;
		while(l > 0) {
			let k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	writeFullBytes(s,pos,len) {
		while(len > 0) {
			let k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	writeUInt16(x) {
		if(x < 0 || x >= 65536) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	writeInt32(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	writeString(s,encoding) {
		let b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
}
haxe_io_Output.__name__ = "haxe.io.Output";
Object.assign(haxe_io_Output.prototype, {
	__class__: haxe_io_Output
});
class haxe_io_BytesOutput extends haxe_io_Output {
	constructor() {
		super();
		this.b = new haxe_io_BytesBuffer();
	}
	writeByte(c) {
		this.b.addByte(c);
	}
	writeBytes(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	getBytes() {
		return this.b.getBytes();
	}
}
haxe_io_BytesOutput.__name__ = "haxe.io.BytesOutput";
Object.assign(haxe_io_BytesOutput.prototype, {
	__class__: haxe_io_BytesOutput
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
class haxe_xml_XmlParserException {
	constructor(message,xml,position) {
		this.xml = xml;
		this.message = message;
		this.position = position;
		this.lineNumber = 1;
		this.positionAtLine = 0;
		let _g = 0;
		let _g1 = position;
		while(_g < _g1) {
			let i = _g++;
			let c = xml.charCodeAt(i);
			if(c == 10) {
				this.lineNumber++;
				this.positionAtLine = 0;
			} else if(c != 13) {
				this.positionAtLine++;
			}
		}
	}
	toString() {
		let c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
}
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
Object.assign(haxe_xml_XmlParserException.prototype, {
	__class__: haxe_xml_XmlParserException
});
class haxe_xml_Parser {
	static parse(str,strict) {
		if(strict == null) {
			strict = false;
		}
		let doc = Xml.createDocument();
		haxe_xml_Parser.doParse(str,strict,0,doc);
		return doc;
	}
	static doParse(str,strict,p,parent) {
		if(p == null) {
			p = 0;
		}
		let xml = null;
		let state = 1;
		let next = 1;
		let aname = null;
		let start = 0;
		let nsubs = 0;
		let nbrackets = 0;
		let c = str.charCodeAt(p);
		let buf = new StringBuf();
		let escapeNext = 1;
		let attrValQuote = -1;
		while(c == c) {
			switch(state) {
			case 0:
				switch(c) {
				case 9:case 10:case 13:case 32:
					break;
				default:
					state = next;
					continue;
				}
				break;
			case 1:
				if(c == 60) {
					state = 0;
					next = 2;
				} else {
					start = p;
					state = 13;
					continue;
				}
				break;
			case 2:
				switch(c) {
				case 33:
					if(str.charCodeAt(p + 1) == 91) {
						p += 2;
						if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
						}
						p += 5;
						state = 17;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
						if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
						}
						p += 8;
						state = 16;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
					} else {
						p += 2;
						state = 15;
						start = p + 1;
					}
					break;
				case 47:
					if(parent == null) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					start = p + 1;
					state = 0;
					next = 10;
					break;
				case 63:
					state = 14;
					start = p;
					break;
				default:
					state = 3;
					start = p;
					continue;
				}
				break;
			case 3:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(p == start) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
					parent.addChild(xml);
					++nsubs;
					state = 0;
					next = 4;
					continue;
				}
				break;
			case 4:
				switch(c) {
				case 47:
					state = 11;
					break;
				case 62:
					state = 9;
					break;
				default:
					state = 5;
					start = p;
					continue;
				}
				break;
			case 5:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
					}
					let tmp = HxOverrides.substr(str,start,p - start);
					aname = tmp;
					if(xml.exists(aname)) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
					}
					state = 0;
					next = 6;
					continue;
				}
				break;
			case 6:
				if(c == 61) {
					state = 0;
					next = 7;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
				}
				break;
			case 7:
				switch(c) {
				case 34:case 39:
					buf = new StringBuf();
					state = 8;
					start = p + 1;
					attrValQuote = c;
					break;
				default:
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
				}
				break;
			case 8:
				switch(c) {
				case 38:
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 8;
					start = p + 1;
					break;
				case 60:case 62:
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
					} else if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
					break;
				default:
					if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
				}
				break;
			case 9:
				p = haxe_xml_Parser.doParse(str,strict,p,xml);
				start = p;
				state = 1;
				break;
			case 10:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					let v = HxOverrides.substr(str,start,p - start);
					if(parent == null || parent.nodeType != 0) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
					}
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					if(v != parent.nodeName) {
						if(parent.nodeType != Xml.Element) {
							throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
						}
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
					}
					state = 0;
					next = 12;
					continue;
				}
				break;
			case 11:
				if(c == 62) {
					state = 1;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 12:
				if(c == 62) {
					if(nsubs == 0) {
						parent.addChild(Xml.createPCData(""));
					}
					return p;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 13:
				if(c == 60) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					let child = Xml.createPCData(buf.b);
					buf = new StringBuf();
					parent.addChild(child);
					++nsubs;
					state = 0;
					next = 2;
				} else if(c == 38) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 13;
					start = p + 1;
				}
				break;
			case 14:
				if(c == 63 && str.charCodeAt(p + 1) == 62) {
					++p;
					let str1 = HxOverrides.substr(str,start + 1,p - start - 2);
					parent.addChild(Xml.createProcessingInstruction(str1));
					++nsubs;
					state = 1;
				}
				break;
			case 15:
				if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
					parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 16:
				if(c == 91) {
					++nbrackets;
				} else if(c == 93) {
					--nbrackets;
				} else if(c == 62 && nbrackets == 0) {
					parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					state = 1;
				}
				break;
			case 17:
				if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
					let child = Xml.createCData(HxOverrides.substr(str,start,p - start));
					parent.addChild(child);
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 18:
				if(c == 59) {
					let s = HxOverrides.substr(str,start,p - start);
					if(s.charCodeAt(0) == 35) {
						let c = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
						buf.b += String.fromCodePoint(c);
					} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
						if(strict) {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
						}
						buf.b += Std.string("&" + s + ";");
					} else {
						buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
					}
					start = p + 1;
					state = escapeNext;
				} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
					}
					buf.b += String.fromCodePoint(38);
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					--p;
					start = p + 1;
					state = escapeNext;
				}
				break;
			}
			c = str.charCodeAt(++p);
		}
		if(state == 1) {
			start = p;
			state = 13;
		}
		if(state == 13) {
			if(parent.nodeType == 0) {
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
			}
			if(p != start || nsubs == 0) {
				let len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				parent.addChild(Xml.createPCData(buf.b));
				++nsubs;
			}
			return p;
		}
		if(!strict && state == 18 && escapeNext == 13) {
			buf.b += String.fromCodePoint(38);
			let len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
			return p;
		}
		throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
	}
}
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
class haxe_xml_Printer {
	constructor(pretty) {
		this.output = new StringBuf();
		this.pretty = pretty;
	}
	writeNode(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			let attribute = value.attributes();
			while(attribute.hasNext()) {
				let attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				let input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				let _g_current = 0;
				let _g_array = value.children;
				while(_g_current < _g_array.length) {
					let child = _g_array[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				let input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let commentContent = value.nodeValue;
			let _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			let input = StringTools.trim(commentContent);
			this.output.b += Std.string(input);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let _g_current = 0;
			let _g_array = value.children;
			while(_g_current < _g_array.length) {
				let child = _g_array[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	hasChildren(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		let _g_current = 0;
		let _g_array = value.children;
		while(_g_current < _g_array.length) {
			let child = _g_array[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	static print(xml,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		let printer = new haxe_xml_Printer(pretty);
		printer.writeNode(xml,"");
		return printer.output.b;
	}
}
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
Object.assign(haxe_xml_Printer.prototype, {
	__class__: haxe_xml_Printer
});
var haxe_zip_ExtraField = $hxEnums["haxe.zip.ExtraField"] = { __ename__ : true, __constructs__ : ["FUnknown","FInfoZipUnicodePath","FUtf8"]
	,FUnknown: ($_=function(tag,bytes) { return {_hx_index:0,tag:tag,bytes:bytes,__enum__:"haxe.zip.ExtraField",toString:$estr}; },$_.__params__ = ["tag","bytes"],$_)
	,FInfoZipUnicodePath: ($_=function(name,crc) { return {_hx_index:1,name:name,crc:crc,__enum__:"haxe.zip.ExtraField",toString:$estr}; },$_.__params__ = ["name","crc"],$_)
	,FUtf8: {_hx_index:2,__enum__:"haxe.zip.ExtraField",toString:$estr}
};
class haxe_zip_Writer {
	constructor(o) {
		this.o = o;
		this.files = new haxe_ds_List();
	}
	writeZipDate(date) {
		let hour = date.getHours();
		let min = date.getMinutes();
		let sec = date.getSeconds() >> 1;
		this.o.writeUInt16(hour << 11 | min << 5 | sec);
		let year = date.getFullYear() - 1980;
		let month = date.getMonth() + 1;
		let day = date.getDate();
		this.o.writeUInt16(year << 9 | month << 5 | day);
	}
	writeEntryHeader(f) {
		let o = this.o;
		let flags = 0;
		if(f.extraFields != null) {
			let _g_head = f.extraFields.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				let e = val;
				if(e._hx_index == 2) {
					flags |= 2048;
				}
			}
		}
		o.writeInt32(67324752);
		o.writeUInt16(20);
		o.writeUInt16(flags);
		if(f.data == null) {
			f.fileSize = 0;
			f.dataSize = 0;
			f.crc32 = 0;
			f.compressed = false;
			f.data = new haxe_io_Bytes(new ArrayBuffer(0));
		} else {
			if(f.crc32 == null) {
				if(f.compressed) {
					throw haxe_Exception.thrown("CRC32 must be processed before compression");
				}
				f.crc32 = haxe_crypto_Crc32.make(f.data);
			}
			if(!f.compressed) {
				f.fileSize = f.data.length;
			}
			f.dataSize = f.data.length;
		}
		o.writeUInt16(f.compressed ? 8 : 0);
		this.writeZipDate(f.fileTime);
		o.writeInt32(f.crc32);
		o.writeInt32(f.dataSize);
		o.writeInt32(f.fileSize);
		o.writeUInt16(f.fileName.length);
		let e = new haxe_io_BytesOutput();
		if(f.extraFields != null) {
			let _g_head = f.extraFields.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				let f = val;
				switch(f._hx_index) {
				case 0:
					let bytes = f.bytes;
					let tag = f.tag;
					e.writeUInt16(tag);
					e.writeUInt16(bytes.length);
					e.write(bytes);
					break;
				case 1:
					let crc = f.crc;
					let name = f.name;
					let namebytes = haxe_io_Bytes.ofString(name);
					e.writeUInt16(28789);
					e.writeUInt16(namebytes.length + 5);
					e.writeByte(1);
					e.writeInt32(crc);
					e.write(namebytes);
					break;
				case 2:
					break;
				}
			}
		}
		let ebytes = e.getBytes();
		o.writeUInt16(ebytes.length);
		o.writeString(f.fileName);
		o.write(ebytes);
		this.files.add({ name : f.fileName, compressed : f.compressed, clen : f.data.length, size : f.fileSize, crc : f.crc32, date : f.fileTime, fields : ebytes});
	}
	write(files) {
		let _g_head = files.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			let f = val;
			this.writeEntryHeader(f);
			this.o.writeFullBytes(f.data,0,f.data.length);
		}
		this.writeCDR();
	}
	writeCDR() {
		let cdr_size = 0;
		let cdr_offset = 0;
		let _g_head = this.files.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			let f = val;
			let namelen = f.name.length;
			let extraFieldsLength = f.fields.length;
			this.o.writeInt32(33639248);
			this.o.writeUInt16(20);
			this.o.writeUInt16(20);
			this.o.writeUInt16(0);
			this.o.writeUInt16(f.compressed ? 8 : 0);
			this.writeZipDate(f.date);
			this.o.writeInt32(f.crc);
			this.o.writeInt32(f.clen);
			this.o.writeInt32(f.size);
			this.o.writeUInt16(namelen);
			this.o.writeUInt16(extraFieldsLength);
			this.o.writeUInt16(0);
			this.o.writeUInt16(0);
			this.o.writeUInt16(0);
			this.o.writeInt32(0);
			this.o.writeInt32(cdr_offset);
			this.o.writeString(f.name);
			this.o.write(f.fields);
			cdr_size += 46 + namelen + extraFieldsLength;
			cdr_offset += 30 + namelen + extraFieldsLength + f.clen;
		}
		this.o.writeInt32(101010256);
		this.o.writeUInt16(0);
		this.o.writeUInt16(0);
		this.o.writeUInt16(this.files.length);
		this.o.writeUInt16(this.files.length);
		this.o.writeInt32(cdr_size);
		this.o.writeInt32(cdr_offset);
		this.o.writeUInt16(0);
	}
}
haxe_zip_Writer.__name__ = "haxe.zip.Writer";
Object.assign(haxe_zip_Writer.prototype, {
	__class__: haxe_zip_Writer
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let n = e.__constructs__[o._hx_index];
				let con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = "js.Boot";
class js_Browser {
	static createXMLHttpRequest() {
		if(typeof XMLHttpRequest != "undefined") {
			return new XMLHttpRequest();
		}
		if(typeof ActiveXObject != "undefined") {
			return new ActiveXObject("Microsoft.XMLHTTP");
		}
		throw haxe_Exception.thrown("Unable to create XMLHttpRequest object.");
	}
}
js_Browser.__name__ = "js.Browser";
class sdd_CategoricalRef {
	constructor(ref,stateRefs) {
		this.ref = ref;
		this.stateRefs = stateRefs;
	}
}
sdd_CategoricalRef.__name__ = "sdd.CategoricalRef";
Object.assign(sdd_CategoricalRef.prototype, {
	__class__: sdd_CategoricalRef
});
class sdd_Representation {
	constructor(label,detail,mediaObjectsRefs) {
		if(sdd_Representation._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(label,detail,mediaObjectsRefs);
	}
	_hx_constructor(label,detail,mediaObjectsRefs) {
		this.mediaObjectsRefs = [];
		this.label = label;
		this.detail = detail;
		if(mediaObjectsRefs != null) {
			this.mediaObjectsRefs = mediaObjectsRefs;
		}
	}
}
sdd_Representation.__name__ = "sdd.Representation";
Object.assign(sdd_Representation.prototype, {
	__class__: sdd_Representation
});
class sdd_Character extends sdd_Representation {
	constructor(id,parentId,representation,states,inapplicableStatesRefs,childrenIds) {
		sdd_Representation._hx_skip_constructor = true;
		super();
		sdd_Representation._hx_skip_constructor = false;
		this._hx_constructor(id,parentId,representation,states,inapplicableStatesRefs,childrenIds);
	}
	_hx_constructor(id,parentId,representation,states,inapplicableStatesRefs,childrenIds) {
		this.childrenIds = [];
		this.inapplicableStatesRefs = [];
		this.states = [];
		super._hx_constructor(representation.label,representation.detail,representation.mediaObjectsRefs);
		this.id = id;
		if(states != null) {
			this.states = states;
		}
		if(inapplicableStatesRefs != null) {
			this.inapplicableStatesRefs = inapplicableStatesRefs;
		}
		if(childrenIds != null) {
			this.childrenIds = childrenIds;
		}
	}
}
sdd_Character.__name__ = "sdd.Character";
Object.assign(sdd_Character.prototype, {
	__class__: sdd_Character
});
class sdd_Dataset {
	constructor(taxons,characters,states,mediaObjects) {
		this.taxons = taxons;
		this.characters = characters;
		this.states = states;
		this.mediaObjects = mediaObjects;
	}
}
sdd_Dataset.__name__ = "sdd.Dataset";
Object.assign(sdd_Dataset.prototype, {
	__class__: sdd_Dataset
});
class sdd_TaxonHierarchy {
	constructor(taxon,childrenHierarchyIds) {
		this.taxon = taxon;
		this.childrenHierarchyIds = childrenHierarchyIds;
	}
}
sdd_TaxonHierarchy.__name__ = "sdd.TaxonHierarchy";
Object.assign(sdd_TaxonHierarchy.prototype, {
	__class__: sdd_TaxonHierarchy
});
class sdd_CharactersAndStatesById {
	constructor(charactersById,statesById) {
		this.charactersById = charactersById;
		this.statesById = statesById;
	}
}
sdd_CharactersAndStatesById.__name__ = "sdd.CharactersAndStatesById";
Object.assign(sdd_CharactersAndStatesById.prototype, {
	__class__: sdd_CharactersAndStatesById
});
class sdd_Loader {
	constructor(strictMode) {
		if(strictMode == null) {
			strictMode = true;
		}
		this.exceptionLog = [];
		this.strictMode = strictMode;
	}
	loadDataset(datasetElement) {
		let mediaObjectsById = this.loadMediaObjects(datasetElement);
		let charsAndStatesById = this.loadDatasetCharacters(datasetElement,mediaObjectsById);
		return new sdd_Dataset(Lambda.array(this.loadDatasetTaxons(datasetElement,mediaObjectsById,charsAndStatesById.charactersById)),Lambda.array(charsAndStatesById.charactersById),Lambda.array(charsAndStatesById.statesById),Lambda.array(mediaObjectsById));
	}
	loadMediaObjects(datasetElement) {
		let mediaObjectsElement = sdd_XmlExtensions.firstElementNamed(datasetElement,"MediaObjects");
		let mediaObjectsById = new haxe_ds_StringMap();
		if(mediaObjectsElement == null) {
			return mediaObjectsById;
		}
		let mediaObjectElement = mediaObjectsElement.elementsNamed("MediaObject");
		while(mediaObjectElement.hasNext()) {
			let mediaObjectElement1 = mediaObjectElement.next();
			let sourceElement = sdd_XmlExtensions.firstElementNamed(mediaObjectElement1,"Source");
			if(sourceElement != null) {
				let value = mediaObjectElement1.get("id");
				let exception = new sdd_SddException("A MediaObject declaration misses its 'id'.");
				if(value == null) {
					throw exception;
				}
				let id = value;
				let representation = this.loadRepresentation(sdd_XmlExtensions.firstElementNamed(mediaObjectElement1,"Representation"),mediaObjectsById);
				let value1 = new sdd_MediaObject(id,sourceElement.get("href"),representation.label,representation.detail);
				mediaObjectsById.h[id] = value1;
			}
		}
		return mediaObjectsById;
	}
	loadRepresentation(representationElement,mediaObjectsByRef) {
		if(representationElement == null) {
			return new sdd_Representation("","",[]);
		}
		let mediaObjectsRefs = [];
		let mediaObjectElement = representationElement.elementsNamed("MediaObject");
		while(mediaObjectElement.hasNext()) {
			let mediaObjectElement1 = mediaObjectElement.next();
			let value = mediaObjectElement1.get("ref");
			let exception = new sdd_SddException("A MediaObject is missing its ref.");
			if(value == null) {
				throw exception;
			}
			mediaObjectsRefs.push(new sdd_MediaObjectRef(value));
		}
		let labelNode = sdd_XmlExtensions.firstElementNamed(representationElement,"Label");
		let detailElement = sdd_XmlExtensions.firstElementNamed(representationElement,"Detail");
		return new sdd_Representation(labelNode != null ? sdd_XmlExtensions.innerText(labelNode) : "_",detailElement != null ? sdd_XmlExtensions.innerText(detailElement) : "_",mediaObjectsRefs);
	}
	logException(exception) {
		this.exceptionLog.push(exception.get_message());
	}
	assertNotNull(value,exception) {
		if(value == null) {
			throw exception;
		}
		return value;
	}
	loadDatasetTaxons(datasetElement,mediaObjectsById,charactersById) {
		let taxonsById = new haxe_ds_StringMap();
		let taxonNamesElement = sdd_XmlExtensions.firstElementNamed(datasetElement,"TaxonNames");
		if(taxonNamesElement == null) {
			return new haxe_ds_StringMap();
		}
		let taxonElement = taxonNamesElement.elementsNamed("TaxonName");
		while(taxonElement.hasNext()) {
			let taxonElement1 = taxonElement.next();
			let value = taxonElement1.get("id");
			let exception = new sdd_SddException("A Taxon is missing its 'id'.");
			if(value == null) {
				throw exception;
			}
			let taxonId = value;
			let value1 = new sdd_Taxon(taxonId,null,this.loadRepresentation(sdd_XmlExtensions.firstElementNamed(taxonElement1,"Representation"),mediaObjectsById));
			taxonsById.h[taxonId] = value1;
		}
		let codedDescriptionsElement = sdd_XmlExtensions.firstElementNamed(datasetElement,"CodedDescriptions");
		if(codedDescriptionsElement != null) {
			let codedDescriptionElement = codedDescriptionsElement.elementsNamed("CodedDescription");
			while(codedDescriptionElement.hasNext()) {
				let codedDescriptionElement1 = codedDescriptionElement.next();
				try {
					let value = sdd_XmlExtensions.firstElementNamed(codedDescriptionElement1,"Scope");
					let exception = new sdd_SddException("A CodedDescription is missing its 'Scope'.");
					if(value == null) {
						throw exception;
					}
					let scopeElement = value;
					let value1 = sdd_XmlExtensions.firstElementNamed(scopeElement,"TaxonName");
					let exception1 = new sdd_SddException("A CodedDescription Scope doesn't have a 'Taxon' element, which is the only one supported by this loader.");
					if(value1 == null) {
						throw exception1;
					}
					let taxonNameElement = value1;
					let value2 = taxonNameElement.get("ref");
					let exception2 = new sdd_SddException("A TaxonName is missing its 'ref'.");
					if(value2 == null) {
						throw exception2;
					}
					let taxonId = value2;
					let representation = this.loadRepresentation(sdd_XmlExtensions.firstElementNamed(codedDescriptionElement1,"Representation"),mediaObjectsById);
					let value3 = taxonsById.h[taxonId];
					let exception3 = new sdd_SddRefException("Scope > TaxonName","Taxon",taxonId);
					if(value3 == null) {
						throw exception3;
					}
					let taxonToAugment = value3;
					if(representation != null) {
						let s = representation.label;
						if(!(s == null || s == "")) {
							taxonToAugment.label = representation.label;
						}
						let s1 = representation.detail;
						if(!(s1 == null || s1 == "")) {
							taxonToAugment.detail = representation.detail;
						}
						if(representation.mediaObjectsRefs != null && representation.mediaObjectsRefs.length > 0) {
							taxonToAugment.mediaObjectsRefs = representation.mediaObjectsRefs;
						}
					}
					let summaryDataElement = sdd_XmlExtensions.firstElementNamed(codedDescriptionElement1,"SummaryData");
					if(summaryDataElement != null) {
						let categoricalElements = summaryDataElement.elementsNamed("Categorical");
						let categoricalElement = categoricalElements;
						while(categoricalElement.hasNext()) {
							let categoricalElement1 = categoricalElement.next();
							let value = categoricalElement1.get("ref");
							let exception = new sdd_SddException("A Categorical is missing its 'ref'.");
							if(value == null) {
								throw exception;
							}
							let categorical = new sdd_CategoricalRef(value,[]);
							let stateElement = categoricalElement1.elementsNamed("State");
							while(stateElement.hasNext()) {
								let stateElement1 = stateElement.next();
								let value = stateElement1.get("ref");
								let exception = new sdd_SddException("A State is missing its 'ref'.");
								if(value == null) {
									throw exception;
								}
								let stateId = value;
								categorical.stateRefs.push(new sdd_StateRef(stateId));
							}
							taxonToAugment.categoricals.push(categorical);
						}
					}
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					if(((_g1) instanceof sdd_SddException)) {
						let e = _g1;
						if(this.strictMode) {
							throw e;
						} else {
							this.logException(e);
						}
					} else {
						throw _g;
					}
				}
			}
		}
		let taxonHierarchiesElement = sdd_XmlExtensions.firstElementNamed(datasetElement,"TaxonHierarchies");
		let taxonHierarchyElement = taxonHierarchiesElement != null ? sdd_XmlExtensions.firstElementNamed(taxonHierarchiesElement,"TaxonHierarchy") : null;
		let nodesElement = taxonHierarchyElement != null ? sdd_XmlExtensions.firstElementNamed(taxonHierarchyElement,"Nodes") : null;
		if(nodesElement != null) {
			let hierarchiesById_h = Object.create(null);
			let nodeElement = nodesElement.elementsNamed("Node");
			while(nodeElement.hasNext()) {
				let nodeElement1 = nodeElement.next();
				try {
					let value = nodeElement1.get("id");
					let exception = new sdd_SddException("A TaxonHierarchy > Nodes > Node is missing its 'id'.");
					if(value == null) {
						throw exception;
					}
					let hierarchyId = value;
					let value1 = sdd_XmlExtensions.firstElementNamed(nodeElement1,"TaxonName");
					let exception1 = new sdd_SddException("A TaxonHierarchy > Nodes > Node is missing its 'TaxonName'.");
					if(value1 == null) {
						throw exception1;
					}
					let taxonNameElement = value1;
					let value2 = taxonNameElement.get("ref");
					let exception2 = new sdd_SddException("A TaxonHierarchy > Nodes > Node > TaxonName is missing its 'ref'.");
					if(value2 == null) {
						throw exception2;
					}
					let taxonId = value2;
					let value3 = taxonsById.h[taxonId];
					let exception3 = new sdd_SddRefException("TaxonHierarchy > Nodes > Node > TaxonName","Taxons",taxonId);
					if(value3 == null) {
						throw exception3;
					}
					let taxon = value3;
					let hierarchy = hierarchiesById_h[hierarchyId];
					taxon.hid = hierarchyId;
					if(hierarchy == null) {
						hierarchy = new sdd_TaxonHierarchy(taxon,[]);
					} else {
						hierarchy.taxon = taxon;
					}
					hierarchiesById_h[hierarchyId] = hierarchy;
					let parentElement = sdd_XmlExtensions.firstElementNamed(nodeElement1,"Parent");
					if(parentElement != null) {
						let value = parentElement.get("ref");
						let exception = new sdd_SddException("A TaxonHierarchy >> Parent is missing its 'ref'.");
						if(value == null) {
							throw exception;
						}
						let parentId = value;
						let parent = hierarchiesById_h[parentId];
						if(parent == null) {
							parent = new sdd_TaxonHierarchy(null,[hierarchyId]);
							hierarchiesById_h[parentId] = parent;
						} else {
							parent.childrenHierarchyIds.push(hierarchyId);
						}
					}
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g);
					if(((_g1) instanceof sdd_SddException)) {
						let e = _g1;
						if(this.strictMode) {
							throw e;
						} else {
							this.logException(e);
						}
					} else {
						throw _g;
					}
				}
			}
			let hierarchy = haxe_ds_StringMap.valueIterator(hierarchiesById_h);
			while(hierarchy.hasNext()) {
				let hierarchy1 = hierarchy.next();
				if(hierarchy1.taxon == null) {
					console.log("src/sdd/Loader.hx:207:",hierarchy1);
				}
				let augmentedTaxon = hierarchy1.taxon;
				let _g = 0;
				let _g1 = hierarchy1.childrenHierarchyIds;
				while(_g < _g1.length) {
					let hid = _g1[_g];
					++_g;
					let child = hierarchiesById_h[hid].taxon;
					child.parentId = augmentedTaxon.id;
					augmentedTaxon.childrenIds.push(child.id);
				}
			}
		}
		return taxonsById;
	}
	loadDatasetCharacters(datasetElement,mediaObjectsById) {
		let charactersById = new haxe_ds_StringMap();
		let charactersElements = sdd_XmlExtensions.firstElementNamed(datasetElement,"Characters");
		let statesById = new haxe_ds_StringMap();
		if(charactersElements == null) {
			return new sdd_CharactersAndStatesById(charactersById,statesById);
		}
		let characterElement = charactersElements.elements();
		while(characterElement.hasNext()) {
			let characterElement1 = characterElement.next();
			try {
				let tmp;
				if(characterElement1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (characterElement1.nodeType == null ? "null" : XmlType.toString(characterElement1.nodeType)));
				}
				if(characterElement1.nodeName != "CategoricalCharacter") {
					if(characterElement1.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (characterElement1.nodeType == null ? "null" : XmlType.toString(characterElement1.nodeType)));
					}
					tmp = characterElement1.nodeName != "QuantitativeCharacter";
				} else {
					tmp = false;
				}
				if(tmp) {
					continue;
				}
				let value = characterElement1.get("id");
				let exception = new sdd_SddException("A Character is missing its 'id'.");
				if(value == null) {
					throw exception;
				}
				let characterId = value;
				let statesElement = sdd_XmlExtensions.firstElementNamed(characterElement1,"States");
				let states = [];
				if(statesElement != null) {
					let stateElement = statesElement.elementsNamed("StateDefinition");
					while(stateElement.hasNext()) {
						let stateElement1 = stateElement.next();
						let value = stateElement1.get("id");
						let exception = new sdd_SddException("A State is missing its 'id'");
						if(value == null) {
							throw exception;
						}
						let stateId = value;
						let state = new sdd_State(stateId,characterId,this.loadRepresentation(sdd_XmlExtensions.firstElementNamed(stateElement1,"Representation"),mediaObjectsById));
						statesById.h[stateId] = state;
						states.push(state);
					}
				}
				let value1 = new sdd_Character(characterId,null,this.loadRepresentation(sdd_XmlExtensions.firstElementNamed(characterElement1,"Representation"),mediaObjectsById),states);
				charactersById.h[characterId] = value1;
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g);
				if(((_g1) instanceof sdd_SddException)) {
					let e = _g1;
					if(this.strictMode) {
						throw e;
					} else {
						this.logException(e);
					}
				} else {
					throw _g;
				}
			}
		}
		let characterTreesElement = sdd_XmlExtensions.firstElementNamed(datasetElement,"CharacterTrees");
		if(characterTreesElement != null) {
			let characterTreeElement = characterTreesElement.elementsNamed("CharacterTree");
			while(characterTreeElement.hasNext()) {
				let characterTreeElement1 = characterTreeElement.next();
				let nodesElement = sdd_XmlExtensions.firstElementNamed(characterTreeElement1,"Nodes");
				if(nodesElement != null) {
					let charNodeElement = nodesElement.elementsNamed("CharNode");
					while(charNodeElement.hasNext()) {
						let charNodeElement1 = charNodeElement.next();
						try {
							let value = sdd_XmlExtensions.firstElementNamed(charNodeElement1,"Character");
							let exception = new sdd_SddException("A CharNode is missing its 'Character'.");
							if(value == null) {
								throw exception;
							}
							let characterElement = value;
							let value1 = characterElement.get("ref");
							let exception1 = new sdd_SddException("A CharNode > Character is missing its 'ref.");
							if(value1 == null) {
								throw exception1;
							}
							let characterRef = value1;
							let value2 = charactersById.h[characterRef];
							let exception2 = new sdd_SddRefException("CharNode > Character","Character",characterRef);
							if(value2 == null) {
								throw exception2;
							}
							let augmentedCharacter = value2;
							let dependencyRulesElement = sdd_XmlExtensions.firstElementNamed(charNodeElement1,"DependencyRules");
							if(dependencyRulesElement != null) {
								let inapplicableIfElement = sdd_XmlExtensions.firstElementNamed(dependencyRulesElement,"InapplicableIf");
								if(inapplicableIfElement != null) {
									let stateElement = inapplicableIfElement.elementsNamed("State");
									while(stateElement.hasNext()) {
										let stateElement1 = stateElement.next();
										let value = stateElement1.get("ref");
										let exception = new sdd_SddException("A InapplicableIf > State is missing its 'ref'.");
										if(value == null) {
											throw exception;
										}
										let stateRef = value;
										let value1 = statesById.h[stateRef];
										let exception1 = new sdd_SddRefException("InapplicableIf > State","State",stateRef);
										if(value1 == null) {
											throw exception1;
										}
										let state = value1;
										augmentedCharacter.inapplicableStatesRefs.push(new sdd_StateRef(state.id));
										augmentedCharacter.parentId = state.characterId;
									}
								}
							}
							if(augmentedCharacter.inapplicableStatesRefs.length > 0) {
								charactersById.h[augmentedCharacter.parentId].childrenIds.push(augmentedCharacter.id);
							}
						} catch( _g ) {
							let _g1 = haxe_Exception.caught(_g);
							if(((_g1) instanceof sdd_SddException)) {
								let e = _g1;
								if(this.strictMode) {
									throw e;
								} else {
									this.logException(e);
								}
							} else {
								throw _g;
							}
						}
					}
				}
			}
		}
		return new sdd_CharactersAndStatesById(charactersById,statesById);
	}
	load(text) {
		let xml = Xml.parse(text);
		let datasetsElements = xml.firstElement();
		let datasets = [];
		let datasetElement = datasetsElements.elementsNamed("Dataset");
		while(datasetElement.hasNext()) {
			let datasetElement1 = datasetElement.next();
			datasets.push(this.loadDataset(datasetElement1));
		}
		return datasets;
	}
}
$hx_exports["sdd"]["Loader"] = sdd_Loader;
sdd_Loader.__name__ = "sdd.Loader";
Object.assign(sdd_Loader.prototype, {
	__class__: sdd_Loader
});
class sdd_MediaObject {
	constructor(id,source,label,detail) {
		this.id = id;
		this.source = source;
		this.label = label;
		this.detail = detail;
	}
}
sdd_MediaObject.__name__ = "sdd.MediaObject";
Object.assign(sdd_MediaObject.prototype, {
	__class__: sdd_MediaObject
});
class sdd_MediaObjectRef {
	constructor(ref) {
		this.ref = ref;
	}
}
sdd_MediaObjectRef.__name__ = "sdd.MediaObjectRef";
Object.assign(sdd_MediaObjectRef.prototype, {
	__class__: sdd_MediaObjectRef
});
class sdd_Saver {
	constructor(datasets) {
		this.mediaObjectsCount = 0;
		this.datasets = datasets;
	}
	taxonParentHid(resolve,parentId) {
		let parent = Lambda.find(this.datasets[0].taxons,function(t) {
			return t.id == parentId;
		});
		return parent.hid;
	}
	html(resolve,htmlText) {
		return StringTools.htmlEscape(htmlText);
	}
	save() {
		let sddTemplate = haxe_Resource.getString("sdd_template");
		let template = new haxe_Template(sddTemplate);
		return template.execute({ datasets : this.datasets},this);
	}
}
$hx_exports["sdd"]["Saver"] = sdd_Saver;
sdd_Saver.__name__ = "sdd.Saver";
Object.assign(sdd_Saver.prototype, {
	__class__: sdd_Saver
});
class sdd_SddException extends haxe_Exception {
	constructor(message) {
		super("Invalid SDD: " + message);
	}
}
sdd_SddException.__name__ = "sdd.SddException";
Object.assign(sdd_SddException.prototype, {
	__class__: sdd_SddException
});
class sdd_SddRefException extends sdd_SddException {
	constructor(sourceElement,targetElement,ref) {
		super("A '" + sourceElement + "' references a missing '" + targetElement + "': " + ref);
	}
}
sdd_SddRefException.__name__ = "sdd.SddRefException";
Object.assign(sdd_SddRefException.prototype, {
	__class__: sdd_SddRefException
});
class sdd_State extends sdd_Representation {
	constructor(id,characterId,representation) {
		super(representation.label,representation.detail,representation.mediaObjectsRefs);
		this.id = id;
		this.characterId = characterId;
	}
}
sdd_State.__name__ = "sdd.State";
Object.assign(sdd_State.prototype, {
	__class__: sdd_State
});
class sdd_StateRef {
	constructor(ref) {
		this.ref = ref;
	}
}
sdd_StateRef.__name__ = "sdd.StateRef";
Object.assign(sdd_StateRef.prototype, {
	__class__: sdd_StateRef
});
class sdd_Taxon extends sdd_Representation {
	constructor(id,parentId,representation,childrenIds,categoricals) {
		sdd_Representation._hx_skip_constructor = true;
		super();
		sdd_Representation._hx_skip_constructor = false;
		this._hx_constructor(id,parentId,representation,childrenIds,categoricals);
	}
	_hx_constructor(id,parentId,representation,childrenIds,categoricals) {
		this.childrenIds = [];
		this.categoricals = [];
		super._hx_constructor(representation.label,representation.detail,representation.mediaObjectsRefs);
		this.id = id;
		if(childrenIds != null) {
			this.childrenIds = childrenIds;
		}
		if(categoricals != null) {
			this.categoricals = categoricals;
		}
	}
}
sdd_Taxon.__name__ = "sdd.Taxon";
Object.assign(sdd_Taxon.prototype, {
	__class__: sdd_Taxon
});
class sdd_XmlExtensions {
	static firstElementNamed(xml,tagName) {
		if(xml != null) {
			return xml.elementsNamed(tagName).next();
		} else {
			return null;
		}
	}
	static innerText(xml) {
		if(xml == null) {
			return "";
		}
		if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		let textNode = xml.children[0];
		if(textNode != null) {
			if(textNode.nodeType == Xml.Document || textNode.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (textNode.nodeType == null ? "null" : XmlType.toString(textNode.nodeType)));
			}
			return textNode.nodeValue;
		} else {
			return "";
		}
	}
}
sdd_XmlExtensions.__name__ = "sdd.XmlExtensions";
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = "String";
Array.__name__ = "Array";
Date.prototype.__class__ = Date;
Date.__name__ = "Date";
haxe_Resource.content = [{ name : "tex_template", data : "XGRvY3VtZW50Y2xhc3N7YmVhbWVyfQoKXHVzZXRoZW1le1BhbG9BbHRvfQpcdXNlcGFja2FnZVtmcmVuY2hde2JhYmVsfQpcdXNlcGFja2FnZVt1dGY4XXtpbnB1dGVuY30KXHVzZXBhY2thZ2V7Z3JhcGhpY3h9CgpcZGVmaW5lY29sb3J7R3JlZW59e3JnYn17LjEsLjcyLC4xfQoKXHRpdGxle1RheG9uc30KXGF1dGhvcntUaWFuIExpfSAlClxpbnN0aXR1dGV7TXVzw6l1bSBOYXRpb25hbCBkJ0hpc3RvaXJlIE5hdHVyZWxsZX0KJVxkYXRlezIwMjB9CgpcYmVnaW57ZG9jdW1lbnR9CgoleyUgb3BlbiBhIExvY2FsIFRlWCBHcm91cAolXHNldGJlYW1lcnRlbXBsYXRle3NpZGViYXJ9e30KJSBcYmVnaW57ZnJhbWV9CiUgICAgICAgICBcdGl0bGVwYWdlCiUgICAgICAgICBcYmVnaW57Y2VudGVyfQolICAgICAgICAgICBcaW5jbHVkZWdyYXBoaWNzW3dpZHRoPTNjbV17c2lnbWFsaXMucG5nfQolICAgICAgICAgXGVuZHtjZW50ZXJ9CiUgXGVuZHtmcmFtZX0KJX0lIGVuZCBMb2NhbCBUZVggR3JvdXAKClxzZWN0aW9ue1RheG9uc30KCjo6Zm9yZWFjaCB0YXhvbnM6OgoKXGJlZ2lue2ZyYW1lfQogICAgXGZyYW1ldGl0bGV7OjpuYW1lOjp9CiAgICBcZnJhbWVzdWJ0aXRsZXs6OnZlcm5hY3VsYXJOYW1lOjp9CiAgICBcYmVnaW57YmxvY2t9e0lkZW50aWZpY2F0aW9ufQogICAgOjppZiAocGhvdG9zLmxlbmd0aCA+IDApOjoKICAgICAgXGluY2x1ZGVncmFwaGljc1t3aWR0aD0zY20saGVpZ2h0PTNjbV17JCRwaWN0dXJlKDo6cGhvdG9zOjopfQogICAgOjplbmQ6OgogICAgICBcYmVnaW57aXRlbWl6ZX0KICAgICAgXGl0ZW0gbmFtZTogOjpuYW1lOjoKICAgICAgXGl0ZW0gdmVybmFjdWxhciBuYW1lOiA6OnZlcm5hY3VsYXJOYW1lOjoKICAgICAgXGl0ZW0gY2hpbmVzZSBuYW1lOiA6Om5hbWVDTjo6CiAgICAgIFxlbmR7aXRlbWl6ZX0KICAgIFxlbmR7YmxvY2t9CiAgICBcYmVnaW57YmxvY2t9e0Rlc2NyaXB0aW9ufQogICAgICBcYmVnaW57aXRlbWl6ZX0KICAgICAgXGl0ZW0geWVwCiAgICAgIDo6Zm9yZWFjaCBkZXNjcmlwdGlvbnM6OgogICAgICBcaXRlbSA6OmRlc2NyaXB0b3IubmFtZTo6OiA6OmZvcmVhY2ggc3RhdGVzOjogOjpuYW1lOjogOjplbmQ6OiAKICAgICAgOjplbmQ6OgogICAgICBcZW5ke2l0ZW1pemV9CiAgICBcZW5ke2Jsb2NrfQpcZW5ke2ZyYW1lfQoKOjplbmQ6OgoKXGVuZHtkb2N1bWVudH0K"},{ name : "sdd_template", data : "PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPERhdGFzZXRzIHhtbG5zPSJodHRwOi8vcnMudGR3Zy5vcmcvVUJJRi8yMDA2LyIgeG1sbnM6eHNpPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSIgeHNpOnNjaGVtYUxvY2F0aW9uPSJodHRwOi8vcnMudGR3Zy5vcmcvVUJJRi8yMDA2LyBodHRwOi8vcnMudGR3Zy5vcmcvVUJJRi8yMDA2L1NjaGVtYS8xLjEvU0RELnhzZCI+Cgk8VGVjaG5pY2FsTWV0YWRhdGEgY3JlYXRlZD0iMjAyMC0wNC0yNFQxMjoxMToxNSI+CgkJPEdlbmVyYXRvciBuYW1lPSJYcGVyMyIgbm90ZXM9IlRoaXMgc29mdHdhcmUgaXMgZGV2ZWxvcGVkIGJ5IExJUyAtIExhYm9yYXRvcnkgb2YgSW5mb3JtYXRpY3MgYW5kIFN5c3RlbWF0aWNzIChVbml2ZXJzaXTDg8KpIFBpZXJyZSBldCBNYXJpZSBDdXJpZSwgVU1SIDcyMDUsIEZyYW5jZSkgLSB3d3cuaW5mb3N5c2xhYi5mciIgdmVyc2lvbj0iMS41LjEiIC8+Cgk8L1RlY2huaWNhbE1ldGFkYXRhPgogICAgOjpmb3JlYWNoIGRhdGFzZXRzOjoKICAgIDxEYXRhc2V0IHhtbG5zPSIiIHhtbDpsYW5nPSJmciI+CiAgICAgICAgPFJlcHJlc2VudGF0aW9uPgogICAgICAgICAgICA8TGFiZWw+U2FtcGxlPC9MYWJlbD4KICAgICAgICA8L1JlcHJlc2VudGF0aW9uPgogICAgICAgIDxUYXhvbk5hbWVzPgogICAgICAgICAgICA6OmZvcmVhY2ggdGF4b25zOjoKICAgICAgICAgICAgPFRheG9uTmFtZSBpZD0iOjppZDo6Ij4KICAgICAgICAgICAgICAgIDxSZXByZXNlbnRhdGlvbj4KICAgICAgICAgICAgICAgICAgICA8TGFiZWw+OjpsYWJlbDo6PC9MYWJlbD4KICAgICAgICAgICAgICAgICAgICA8RGV0YWlsPiQkaHRtbCg6OmRldGFpbDo6KTwvRGV0YWlsPgogICAgICAgICAgICAgICAgICAgIDo6Zm9yZWFjaCBtZWRpYU9iamVjdHNSZWZzOjoKICAgICAgICAgICAgICAgICAgICA8TWVkaWFPYmplY3QgcmVmPSI6OnJlZjo6IiAvPgogICAgICAgICAgICAgICAgICAgIDo6ZW5kOjoKICAgICAgICAgICAgICAgIDwvUmVwcmVzZW50YXRpb24+CiAgICAgICAgICAgIDwvVGF4b25OYW1lPgogICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgPC9UYXhvbk5hbWVzPgogICAgICAgIDxUYXhvbkhpZXJhcmNoaWVzPgogICAgICAgICAgICA8VGF4b25IaWVyYXJjaHkgaWQ9InRoMSI+CiAgICAgICAgICAgICAgICA8UmVwcmVzZW50YXRpb24+CiAgICAgICAgICAgICAgICAgICAgPExhYmVsPkRlZmF1bHQgRW50aXR5IFRyZWU8L0xhYmVsPgogICAgICAgICAgICAgICAgPC9SZXByZXNlbnRhdGlvbj4KICAgICAgICAgICAgICAgIDxUYXhvbkhpZXJhcmNoeVR5cGU+VW5zcGVjaWZpZWRUYXhvbm9teTwvVGF4b25IaWVyYXJjaHlUeXBlPgogICAgICAgICAgICAgICAgPE5vZGVzPgogICAgICAgICAgICAgICAgOjpmb3JlYWNoIHRheG9uczo6CiAgICAgICAgICAgICAgICAgICAgPE5vZGUgaWQ9Ijo6aGlkOjoiPgogICAgICAgICAgICAgICAgICAgIDo6aWYgKHBhcmVudElkICE9IG51bGwpOjoKICAgICAgICAgICAgICAgICAgICAgICAgPFBhcmVudCByZWY9IiQkdGF4b25QYXJlbnRIaWQoOjpwYXJlbnRJZDo6KSIgLz4KICAgICAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgICAgICAgICAgICAgIDxUYXhvbk5hbWUgcmVmPSI6OmlkOjoiIC8+CiAgICAgICAgICAgICAgICAgICAgPC9Ob2RlPgogICAgICAgICAgICAgICAgOjplbmQ6OgogICAgICAgICAgICAgICAgPC9Ob2Rlcz4KICAgICAgICAgICAgPC9UYXhvbkhpZXJhcmNoeT4KICAgICAgICA8L1RheG9uSGllcmFyY2hpZXM+CiAgICAgICAgPENoYXJhY3RlcnM+CiAgICAgICAgOjpmb3JlYWNoIGNoYXJhY3RlcnM6OgogICAgICAgICAgICA8Q2F0ZWdvcmljYWxDaGFyYWN0ZXIgaWQ9Ijo6aWQ6OiI+CiAgICAgICAgICAgICAgICA8UmVwcmVzZW50YXRpb24+CiAgICAgICAgICAgICAgICAgICAgPExhYmVsPjo6bGFiZWw6OjwvTGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPERldGFpbD4kJGh0bWwoOjpkZXRhaWw6Oik8L0RldGFpbD4KICAgICAgICAgICAgICAgICAgICA6OmZvcmVhY2ggbWVkaWFPYmplY3RzUmVmczo6CiAgICAgICAgICAgICAgICAgICAgPE1lZGlhT2JqZWN0IHJlZj0iOjpyZWY6OiIgLz4KICAgICAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgICAgICA8L1JlcHJlc2VudGF0aW9uPgogICAgICAgICAgICAgICAgOjppZihzdGF0ZXMubGVuZ3RoID4gMCk6OgogICAgICAgICAgICAgICAgICAgIDxTdGF0ZXM+CiAgICAgICAgICAgICAgICAgICAgOjpmb3JlYWNoIHN0YXRlczo6CiAgICAgICAgICAgICAgICAgICAgICAgIDxTdGF0ZURlZmluaXRpb24gaWQ9Ijo6aWQ6OiI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8UmVwcmVzZW50YXRpb24+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPExhYmVsPjo6bGFiZWw6OjwvTGFiZWw+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERldGFpbD4kJGh0bWwoOjpkZXRhaWw6Oik8L0RldGFpbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6OmZvcmVhY2ggbWVkaWFPYmplY3RzUmVmczo6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE1lZGlhT2JqZWN0IHJlZj0iOjpyZWY6OiIgLz4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1JlcHJlc2VudGF0aW9uPgogICAgICAgICAgICAgICAgICAgICAgICA8L1N0YXRlRGVmaW5pdGlvbj4KICAgICAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgICAgICAgICAgPC9TdGF0ZXM+CiAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgIDwvQ2F0ZWdvcmljYWxDaGFyYWN0ZXI+CiAgICAgICAgOjplbmQ6OgogICAgICAgIDwvQ2hhcmFjdGVycz4KICAgICAgICA8Q2hhcmFjdGVyVHJlZXM+CiAgICAgICAgICAgIDxDaGFyYWN0ZXJUcmVlIGlkPSJjdDEiPgogICAgICAgICAgICAgICAgPFJlcHJlc2VudGF0aW9uPgogICAgICAgICAgICAgICAgICAgIDxMYWJlbD5PcmRyZSBldCBkZXBlbmRhbmNlIGVudHJlIGNhcmFjdGVyZXM8L0xhYmVsPgogICAgICAgICAgICAgICAgPC9SZXByZXNlbnRhdGlvbj4KICAgICAgICAgICAgICAgIDxTaG91bGRDb250YWluQWxsQ2hhcmFjdGVycz50cnVlPC9TaG91bGRDb250YWluQWxsQ2hhcmFjdGVycz4KICAgICAgICAgICAgICAgIDxOb2Rlcz4KICAgICAgICAgICAgICAgIDo6Zm9yZWFjaCBjaGFyYWN0ZXJzOjoKICAgICAgICAgICAgICAgICAgICA8Q2hhck5vZGU+CiAgICAgICAgICAgICAgICAgICAgICAgIDo6aWYgKGluYXBwbGljYWJsZVN0YXRlc0lkcy5sZW5ndGggPiAwKTo6CiAgICAgICAgICAgICAgICAgICAgICAgIDxEZXBlbmRlbmN5UnVsZXM+CgkJCQkJCQk8SW5hcHBsaWNhYmxlSWY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6OmZvcmVhY2ggaW5hcHBsaWNhYmxlU3RhdGVzSWRzOjoKCQkJCQkJCQk8U3RhdGUgcmVmPSI6OnJlZjo6IiAvPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgOjplbmQ6OgoJCQkJCQkJPC9JbmFwcGxpY2FibGVJZj4KCQkJCQkJPC9EZXBlbmRlbmN5UnVsZXM+CiAgICAgICAgICAgICAgICAgICAgICAgIDo6ZW5kOjoKICAgICAgICAgICAgICAgICAgICAgICAgPENoYXJhY3RlciByZWY9Ijo6aWQ6OiIgLz4KICAgICAgICAgICAgICAgICAgICA8L0NoYXJOb2RlPgogICAgICAgICAgICAgICAgOjplbmQ6OgogICAgICAgICAgICAgICAgPC9Ob2Rlcz4KICAgICAgICAgICAgPC9DaGFyYWN0ZXJUcmVlPgogICAgICAgIDwvQ2hhcmFjdGVyVHJlZXM+CiAgICAgICAgPENvZGVkRGVzY3JpcHRpb25zPgogICAgICAgIDo6Zm9yZWFjaCB0YXhvbnM6OgogICAgICAgICAgICA8Q29kZWREZXNjcmlwdGlvbiBpZD0iRDEiPgogICAgICAgICAgICAgICAgPFJlcHJlc2VudGF0aW9uPgogICAgICAgICAgICAgICAgICAgIDxMYWJlbD46OmxhYmVsOjo8L0xhYmVsPgogICAgICAgICAgICAgICAgICAgIDxEZXRhaWw+JCRodG1sKDo6ZGV0YWlsOjopPC9EZXRhaWw+CiAgICAgICAgICAgICAgICAgICAgOjpmb3JlYWNoIG1lZGlhT2JqZWN0c1JlZnM6OgogICAgICAgICAgICAgICAgICAgIDxNZWRpYU9iamVjdCByZWY9Ijo6cmVmOjoiIC8+CiAgICAgICAgICAgICAgICAgICAgOjplbmQ6OgogICAgICAgICAgICAgICAgPC9SZXByZXNlbnRhdGlvbj4KICAgICAgICAgICAgICAgIDxTY29wZT4KICAgICAgICAgICAgICAgICAgICA8VGF4b25OYW1lIHJlZj0iOjppZDo6IiAvPgogICAgICAgICAgICAgICAgPC9TY29wZT4KICAgICAgICAgICAgICAgIDo6aWYgKGNhdGVnb3JpY2Fscy5sZW5ndGggPiAwKTo6CiAgICAgICAgICAgICAgICA8U3VtbWFyeURhdGE+CiAgICAgICAgICAgICAgICA6OmZvcmVhY2ggY2F0ZWdvcmljYWxzOjoKICAgICAgICAgICAgICAgICAgICA8Q2F0ZWdvcmljYWwgcmVmPSI6OnJlZjo6Ij4KICAgICAgICAgICAgICAgICAgICA6OmZvcmVhY2ggc3RhdGVSZWZzOjoKICAgICAgICAgICAgICAgICAgICAgICAgPFN0YXRlIHJlZj0iOjpyZWY6OiIgLz4KICAgICAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgICAgICAgICAgPC9DYXRlZ29yaWNhbD4KICAgICAgICAgICAgICAgIDo6ZW5kOjoKICAgICAgICAgICAgICAgIDwvU3VtbWFyeURhdGE+CiAgICAgICAgICAgICAgICA6OmVuZDo6CiAgICAgICAgICAgIDwvQ29kZWREZXNjcmlwdGlvbj4KICAgICAgICA6OmVuZDo6CiAgICAgICAgPC9Db2RlZERlc2NyaXB0aW9ucz4KICAgICAgICA8TWVkaWFPYmplY3RzPgogICAgICAgIDo6Zm9yZWFjaCBtZWRpYU9iamVjdHM6OgogICAgICAgICAgICA8TWVkaWFPYmplY3QgaWQ9Ijo6aWQ6OiI+CiAgICAgICAgICAgICAgICA8UmVwcmVzZW50YXRpb24+CiAgICAgICAgICAgICAgICAgICAgPExhYmVsPjo6bGFiZWw6OjwvTGFiZWw+CiAgICAgICAgICAgICAgICAgICAgPERldGFpbCByb2xlPSJDYXB0aW9uIj4kJGh0bWwoOjpkZXRhaWw6Oik8L0RldGFpbD4KICAgICAgICAgICAgICAgIDwvUmVwcmVzZW50YXRpb24+CiAgICAgICAgICAgICAgICA8VHlwZT5JbWFnZTwvVHlwZT4KICAgICAgICAgICAgICAgIDxTb3VyY2UgaHJlZj0iOjpzb3VyY2U6OiIgLz4KICAgICAgICAgICAgPC9NZWRpYU9iamVjdD4KICAgICAgICA6OmVuZDo6CiAgICAgICAgPC9NZWRpYU9iamVjdHM+CiAgICA8L0RhdGFzZXQ+CiAgICA6OmVuZDo6CjwvRGF0YXNldHM+"}];
js_Boot.__toStr = ({ }).toString;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
bunga_Book.standard = [new bunga_Book("fmc","Flore de Madagascar et Comores"),new bunga_Book("mbf","Manuel de Botanique Forestire")];
bunga_DetailData._hx_skip_constructor = false;
bunga_Field.standard = [new bunga_Field(true,"name2","Syn"),new bunga_Field(true,"vernacularName","NV"),new bunga_Field(true,"vernacularName2","NV2"),new bunga_Field(true,"meaning","Sense"),new bunga_Field(true,"noHerbier","N Herbier"),new bunga_Field(true,"herbariumPicture","Herbarium Picture"),new bunga_Field(true,"website","Website")];
bunga_FileNameGenerator.forbiddenChars = [" ","*",".","\"","/","\\","[","]",":",";","|",","];
bunga_ImageCache.DB_NAME = "ImageCache";
bunga_ImageCache.DB_VERSION = 1;
haxe_Template.splitter = new EReg("(::[A-Za-z0-9_ ()&|!+=/><*.\"-]+::|\\$\\$([A-Za-z0-9_-]+)\\()","");
haxe_Template.expr_splitter = new EReg("(\\(|\\)|[ \r\n\t]*\"[^\"]*\"[ \r\n\t]*|[!+=/><*.&|-]+)","");
haxe_Template.expr_trim = new EReg("^[ ]*([^ ]+)[ ]*$","");
haxe_Template.expr_int = new EReg("^[0-9]+$","");
haxe_Template.expr_float = new EReg("^([+-]?)(?=\\d|,\\d)\\d*(,\\d*)?([Ee]([+-]?\\d+))?$","");
haxe_Template.globals = { };
haxe_Template.hxKeepArrayIterator = new haxe_iterators_ArrayIterator([]);
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_http_HttpBase._hx_skip_constructor = false;
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	let h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
sdd_Representation._hx_skip_constructor = false;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=SDD.js.map